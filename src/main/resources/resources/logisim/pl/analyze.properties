#
# data/CsvInterpretor.java
#
CsvBitNotSpecified = Linia %d pliku csv "%s" nie zawiera bitu %d zmiennej "%s", przerywającej.
CsvDuplicatedBit = Wiersz %d pliku csv '%s' zawiera dwa razy większy bit %d niż zmienna '%s', przerywana.
CsvDuplicatedVar = Linia %d pliku csv '%s' zawiera wielokrotnie zmienną '%s', przerywaną.
CsvIncorrectBitOrder = Linia %d pliku csv '%s' zawiera nieprawidłową sekwencję bitową dla zmiennej '%s', przerywaną.
CsvIncorrectEmpty = Wiersz %d pliku csv '%s' zawiera nieprawidłowe puste pole w pozycji %d, przerywane.
CsvIncorrectLine = Wiersz %d pliku csv '%s' zawiera wpisy %d zamiast wymaganego %d, przerywający.
CsvIncorrectVarName = Linia %d pliku csv '%s' zawiera nieprawidłowo sformatowaną etykietę '%s', przerywana.
CsvInvalidEntry = Linia %d pliku csv '%s' zawiera nieprawidłowy wpis '%s' w polu %d, przerywający.
CsvNoEntries = Plik "%s" nie zawiera żadnych wpisów, przerywany.
CsvNoInputsFound = Linia %d pliku csv '%s' nie zawiera żadnych wpisów, przerywana.
CsvNoSepFound = Wiersz %d pliku csv '%s' nie zawiera żadnych pól oddzielających, przerywający.
CsvNotEnoughEmpty = Wiersz %d pliku csv '%s' nie zawiera wystarczającej ilości pustych pól po zmiennej '%s', przerywający.
#
# data/ExpressionRenderData.java
#
expressionEmpty = (pusty)
#
# file/AnalyzerTexWriter.java
#
latexBabelLanguage = język angielski
latexEmpty = Pusty analizator
latexEmptyText = Ponieważ analizator nie posiadał zmiennych wejściowych i/lub wyjściowych w momencie generowania tego dokumentu, nie ma czego pokazywać.
latexHeader = Logisim-evolution wygenerowany dokument na %s
latexIntroduction = Wprowadzenie
latexIntroductionText = Ten dokument został wygenerowany przez logisim-evolution. Każda część źródeł TeX-owych może być bez problemu wykorzystana w Twoich własnych dokumentach. W przypadku, gdy chcesz wykorzystać wszystkie/część tych wygenerowanych źródeł TeX-owych, proszę (1) nie zapomnij o dołączeniu wymaganych pakietów, oraz (2) dołącz uwagę, że to źródło zostało wygenerowane przez logisim-evolution.
latexKarnaugh = Wykresy Karnaugha
latexKarnaughEmpty = Puste wykresy Karnaugha
latexKarnaughFilledIn = Wypełniony na wykresach Karnaugh
latexKarnaughFilledInGroups = Wypełnione wykresy Karnaugh z okładkami
latexKarnaughText = W tym rozdziale przedstawiono różne wersje schematów Karnaugha dla poszczególnych funkcji.
latexKarnaughToBig = Nie można wyświetlać wykresów Karnaugha z więcej niż %d vars. wejściowych.
latexMinimal = Wyrażenia minimalne
latexTruthTable = Tabela prawdy
latexTruthTableComlete = Pełna tabela prawdy
latexTruthTableCompact = Zagęszczona tabela prawdy
latexTruthTableText = Tabela może być zbyt duża, aby mogła być wyświetlana na stronie. W czasie generowania nie zostały wykonane żadne obliczenia dotyczące wielkości tabeli w odniesieniu do szerokości/wysokości strony.
latexTruthTableToBig = \\\\~\\\\W tabeli prawdy znajduje się więcej niż %d wpisów, nie ma sensu pokazywać jej tutaj.
tableLatexFilter = Logisim-evolution dokument TeX (*.tex)
#
# file/TruthtableCsvFile.java
#
tableCsvFileFilter = Tabela prawdy Logisim-evolution (*.csv)
#
# file/TruthtableTextFile.java
#
tableParseErrorMessage = Ignoruj błędy i spróbuj ponownie?
tableParseErrorTitle = Błąd parsowania prawdy tableParseErrorTitle = Tabela prawdy parsowania błędów
tableRemark1 = # Tabela prawdy
tableRemark2 = # Wygenerowany z obwodu %s
tableRemark3 = # Wywieziony w %s
tableRemark4 = # Hints and Notes on Formatting:\n# * Możesz edytować ten plik, a następnie zaimportować go z powrotem do Logisim!\n# * Wszystko po '#' jest komentarzem i zostanie zignorowane.\n# * Puste linie i linie separatora (np, ~~~~~~) są ignorowane.\n# * Nazwy kolumn są proste (bez spacji, interpunkcji, itp.)\n# * 'Nazwa[N..0]' oznacza zmienną N+1 bitową, podczas gdy 'Nazwa' sama w sobie oznacza zmienną 1-bitową.\n# * Możesz użyć 'x' lub '-', aby wskazać \"nie obchodzi mnie" zarówno dla bitów wejściowych jak i wyjściowych.\n# * Możesz użyć binarnego (np, "10100011xxxx") lub "n#" lub "hex" (np. "C3x"). Logisim dowie się, który jest który.
tableTxtFileFilter = Tabela prawdy Logisim-evolution (*.txt)
#
# gui/Analyzer.java
#
analyzePleaseWait = proszę czekać
analyzerWindowTitle = Analiza kombinowana
buildCircuitButton = Buduj obwód
exportLatexButton = Eksportuj TeX
exportTableButton = tabela eksportowa
expressionTab = Wyrażenie
expressionTabTip = Przeglądanie i manipulowanie wyrażeniami wyjść.
importTableButton = Tabela importu
inputsOutputsTab = Wejścia & Wyjścia
inputsOutputsTabTip = Podgląd i edycja zbioru zmiennych wejściowych i wyjściowych.
minimizedTab = Zminimalizowany
minimizedTabTip = Widok zminimalizowanych wyrażeń odpowiadających tabeli prawdy.
tableTab = Tabela
tableTabTip = Przeglądaj i manipuluj tabelą prawdy.
#
# gui/BuildCircuitButton.java
#
buildConfirmReplaceMessage = Czy na pewno chcesz wymienić układ %s?
buildConfirmReplaceTitle = Potwierdź wymianę
buildDialogErrorTitle = Nie można zbudować obwodu
buildDialogTitle = Buduj obwód
buildDuplicatedNameError = Nazwa układu nie może być równa nazwie wejścia lub wyjścia. Proszę podać inną nazwę.
buildNameLabel = Nazwa obwodu (Circuit Name):
buildNandsLabel = Użyj tylko NAND Gates.
buildNeedCircuitError = Musisz podać nazwę obwodu.
buildNeedProjectError = Musisz wybrać docelowy projekt.
buildProjectLabel = Projekt docelowy:
buildTwoInputsLabel = Użyj tylko dwóch bramek wejściowych.
replaceCircuitAction = Wymień obwód
#
# gui/CsvReadParameterDialog.java
#
ConfirmCsvParameters = Kontynuuj
cvsFilePreview = Podgląd pierwszych czterech wierszy pliku do odczytu:
seperatorSpace = {spacja}
SeperatorTab = {tab}
UsedQuotesInFile = Wybierz znak "quotote", który jest używany w pliku csv:
UsedSeperatorInFile = Wybierz znak "separatora", który jest używany w pliku csv:
#
# gui/ExportLatexButton.java
#
cantWriteMessage = Nie można zapisać pliku: %s
confirmOverwriteMessage = Czy na pewno chcesz nadpisać plik %s?
confirmOverwriteTitle = Potwierdź nadpisanie (Overwrite)
notFileMessage = Nie plik: %s
saveButton = Tabela prawdy eksportowej
saveErrorTitle = Zapisywanie pliku z błędem
#
# gui/ExpressionTab.java
#
cantImportFormatError = Nie można importować tego typu danych
outputExpressionEdit = Wyrażenia wyjściowe (kliknij dwukrotnie, aby edytować):
#
# gui/ImportTableButton.java
#
cantReadMessage = Nie można odczytać pliku: %s
DoNotKnowHowto = Nie wiem jak odczytać lub zapisać plik '%s' (rozszerzenie powinno być .txt lub .csv).
openButton = Importuj tablicę prawdy
openErrorTitle = Plik odczytu błędów
#
# gui/KarnaughMapPanel.java
#
karnaughNoInputsError = Brak dostępnych wejść.
karnaughNoOutputError = Nie wybrano żadnego wyjścia.
karnaughTooManyInputsError = Zbyt wiele wejść dla tabeli.
NoSelectedKmapGroup = Nie wybrano żadnej grupy.
SelectedKmapGroup = Wybrana grupa:
#
# gui/MinimizedTab.java
#
expressionAltLogicrepresentation = Alternatywna Logika
expressionCalc = Obliczanie wyrażenia
expressionLogicrepresentation = Logiczny
expressionMathrepresentation = Matematyczny
ExpressionNotation = Notacja:
expressionProgbitsrepresentation = Programowanie za pomocą bitów
expressionProgboolsrepresentation = Programowanie za pomocą Booleans
KMapLinedStyle = Podłoga
KmapNumberedStyle = Numerowany
KmapStyle = Styl:
minimizedFormat = Format:
minimizedProductOfSums = Iloczyn sum
minimizedSetButton = Ustaw jako wyrażenie
minimizedSumOfProducts = Suma produktów
#
# gui/OutputSelector.java
#
outputSelectLabel = Wyjście:
#
# gui/TableTab.java
#
tableCompact = Zawalenie się Duplikowane rzędy
tableExpand = Pokaż wszystkie rzędy
tableNoInputs = (brak wejść)
tableNoOutputs = (brak wyjść)
tableRowsShown = %d pokazanych wierszy %d
#
# gui/TableTabCaret.java
#
tabcaretCompactRows = Rzędy zagęszczania
#
# gui/TableTabClip.java
#
clipPasteEndError = Schowek wykracza poza koniec stołu.
clipPasteErrorTitle = Błąd wklejenia
clipPasteSizeError = Region wklejania musi mieć taki sam rozmiar jak schowek.
clipPasteSupportedError = Zawartość schowka nie może być wklejona do edytora.
#
# gui/VariableTab.java
#
inputVariables = Zmienne wejściowe (Input Variables)
outputVariables = Zmienne wyjściowe
variableClickToAdd = kliknij, aby dodać nową zmienną
variableDuplicateError = Nazwa powiela istniejącą zmienną.
variableMaximumError = (Uzyskana maksymalna wielkość %s.).
variablePartError = Nazwa nie może zawierać "%s".
variableRangeFinalPar = Zakres: brak ] bezpośrednio po indeksie LSB.
variableRangeInvalChar = Zakres: nieprawidłowe znaki po zamknięciu ]
variableRangeMSBWrong = Zakres: otwierając [ następna powinna być cyfra
variableRangeStartPar = Zakres: Brakujący gapiący się [
variableRangeWrongLB = Zakres: Indeks MSB musi być większy/równy indeks LSB
variableRangeWrongSep = Zakres: Indeks MSB i indeks LSB muszą być rozdzielone przez ...
variableStartError = Nazwa musi zaczynać się od litery.
#
# model/Entry.java
#
busError = Sprzeczne wartości wyjściowe w układzie.
oscillateError = Obwód oscyluje.
#
# model/Parser.java
#
badVariableName = "%s" nie jest zmienną wejściową.
implicitAndOperator = (Domniemany AND)
invalidCharacterError = nierozpoznane znaki: "%s".
lparenMissingError = brak pasujących nawiasów otwierających.
missingBraceError = Brak pasującego nawiasu otwierającego: "%s"
missingIdentifierError = Brakujący identyfikator przed indeksem: "%s"
missingLeftOperandError = Operator "%s" brak lewego operanda.
missingRightOperandError = Operator "%s" brakujący prawy operand.
missingSubscriptError = Brakujący indeks dolny: "%s"
rparenMissingError = Brak pasującego nawiasu zamykającego.
unexpectedApostrophe = Niespodziewany apostrof ("'")
unexpectedAssignmentError = Nieoczekiwany operator przydziału: "%s"
#
# model/Var.java
#
badVariableBitFormError = Nazwa zmiennej musi mieć postać "nazwa[i]".
badVariableColonError = Nazwa zmiennej musi pojawić się przed ';'
badVariableIndexError = Bitowy indeks zmiennej musi być liczbą całkowitą
variableFormat = Zmienne muszą mieć postać "nazwa[N..0]".
variableTooMuchBits = Zmienne nie mogą mieć więcej niż 32 bitów szerokości


