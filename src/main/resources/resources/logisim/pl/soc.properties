#
# bus/SocBusAttributes.java
#
SocBusTraceSize = Rozmiar śladu:
SocBusTraceVisable = widoczne ślady:
#
# bus/SocBusMenuProvider.java
#
InsertTrans = Włóż transakcję magistralową
SocBusMemMap = Pokaż mapę pamięci
SocBusTraceWindow = Pokaż śledzenie transakcji magistrali
SocInsertTransWindowTitle = Włóż transakcję do magistrali:
TraceWindowTitleDoubleClickOnTraceToRemoveTrace = Okno śledzenia magistrali (dwukrotne kliknięcie na ślad, aby go usunąć)
#
# data/SocBusInfo.java
#
SocBusNotConnectcted = Nie podłączony do magistrali
#
# data/SocBusStateInfo.java
#
SocBusNoTrace = Brak śladów
SocMemMapWindowTitle = Mapa pamięci dla magistrali:
SocMemoryMapOk = Zamknij
SocMemoryMapTitle = Mapa pamięci (kolor czerwony oznacza nakładające się na siebie regiony pamięci):
#
# data/SocBusTransaction.java
#
SocBusStateMaster = Inicjujący:
SocBusStateNoDataMax10chars = brak danych
SocBusStateSlave = Responder:
SocBusStateTraceIndex = Transakcja nr..:
SocTransactionByteAccesNoSupport = Slave nie obsługuje dostępu do bajtów.
SocTransactionByteAccesNoSupportShort = Brak dostępu do bajtów SocTransactionByteAccesNoSupport
SocTransactionHalfWordAccesNoSupport = Slave nie obsługuje dostępu do pół słów.
SocTransactionHalfWordAccesNoSupportShort = Brak dostępu sprzętowego.
SocTransactionMisallignedAddress = Slave wykrył nieprawidłowo ustawiony adres.
SocTransactionMisallignedAddressShort = Niewłaściwie ustawiony adres. Addr.
SocTransactionMultipleSlaveAnswers = Wielu niewolników odpowiedziało na transakcję. Proszę sprawdzić mapę pamięci swoich niewolników.
SocTransactionMultipleSlaveAnswersShort = Wielu niewolników.
SocTransactionNoBusConnectcted = Komponent Master nie jest podłączony do żadnej Socbus. Proszę podłączyć urządzenie Master do komponentu magistrali.
SocTransactionNoBusConnectedShort = Brak magistrali
SocTransactionNoneAtomicRW = Nie jest wymagana żadna atomowa akcja odczytu/zapisu. Nie jest to dozwolone.
SocTransactionNoneAtomicRWShort = Żaden atomowy RW
SocTransactionNoRespons = Żaden element podrzędny nie odpowiedział na zapytanie. Proszę sprawdzić adres pamięci żądania i mapę pamięci systemu.
SocTransactionNoResponsShort = Brak odpowiedzi.
SocTransactionNoSlavesAttached = Podłączona do urządzenia Master magistrala nie ma podłączonych urządzeń Slave. Proszę dołączyć kilka urządzeń podrzędnych (slave) do magistrali.
SocTransactionNoSlavesAttachedShort = Brak Slaves
SocTransactionReadOnlyAccessError = Slave obsługuje tylko dostęp do odczytu pod tym adresem
SocTransactionReadOnlyAccessErrorShort = tylko do odczytu
SocTransactionRegisterDoesNotExist = Slave nie obsługuje żadnego dostępu pod tym adresem
SocTransactionRegisterDoesNotExistShort = brak dostępu
SocTransactionSuccessfull = Nie wystąpił żaden błąd, transakcja jest udana.
SocTransactionSuccessfullShort = Success = Success
SocTransactionUnknownError = Dziwaczny, ten komunikat o błędzie nie powinien nigdy się pojawić i reprezentuje błąd w logisimie.
SocTransactionUnknownErrorShort = BUG!
SocTransactionWordAccesNoSupport = Slave nie obsługuje dostępu do słów.
SocTransactionWordAccesNoSupportShort = Brak dostępu do słów.
SocTransactionWriteOnlyAccessError = Slave nie obsługuje akcji odczytu na tym adresie.
SocTransactionWriteOnlyAccessErrorShort = Tylko do zapisu
#
# data/SocMemMapModel.java
#
SocMemMapEmpty = Pusty (brak niewolników)
SocMemMapEndAddress = adres końcowy:
SocMemMapSlaveName = Nazwa komponentu:
SocMemMapStartAddress = Adres początkowy:
#
# data/SocSimulationManager.java
#
SocBusManagerSelectBus = Proszę wybrać magistralę do połączenia z
SocBusSelectAttr = Podłączona magistrala
SocBusSelectAttrClick = Kliknij, aby wybrać
SocManagerNoBusses = Brak dostępnych autobusów, proszę dodać SOC-bus do schematu.
#
# data/SocUpMenuProvider.java
#
ProcReadElfLoadedAndEntrySet = Udane załadowanie pliku elfów do pamięci.\n Punkt wejścia pliku wykonywalnego został ustawiony na procesor.\n\NNieważne:\n Ponieważ plik elfów nie ma informacji o wektorach wyjątków, musisz je samodzielnie kontrolować!
SocUpMenuAsmWindow = Otwórz assembler
SocUpMenuCpuAsmWindowTitle = monter dla cpu :
SocUpMenuCpuProgramWindowTitle = monter demontażu dla cpu :
SocUpMenuCpuStateWindowTitle = stan procesora dla cpu :
SocUpMenuErrorReadingElfTitle = Błąd w odczytywaniu pliku elf
SocUpMenuReadElf = Odczytywanie pliku elf
SocUpMenuSelectElfFile = Wybierz plik elf do zaimportowania
SocUpMenuShowProgram = Pokaż załadowany program
SocUpMenuShowState = Pokaż stan CPU
#
# data/SocUpSimulationState.java
#
SocUpSimHalt = zatrzymany
SocUpSimHaltBreak = punkt przełamania
SocUpSimHaltError = Błąd
SocUpSimRunning = bieganie
SocUpSimStateLabel = Stan Sim:
SocUpSimstateStart = Start
SocUpSimstateStop = Pauza
SocUpUnknown = Nieznany
#
# file/ElfHeader.java
#
ElfHeaderEIClassError = Nie jest to 32- lub 64-bitowy plik elfowy.
ElfHeaderEIDataError = Niewielki lub duży endian zakodowany plik
ElfHeaderIncorrectEISize = Rozmiar dla przekroju EI jest nieprawidłowy
ElfHeaderIncorrectESize = Rozmiar dla sekcji E jest nieprawidłowy
ElfHeaderIncorrectMagic = Plik nie zawiera poprawnego elf-magika; prawdopodobnie nie jest to plik elfów.
ElfHeaderNoErrors = Nagłówek jest poprawny
ElfHeaderReadingFileError = Błąd odczytu pliku
ElfHeaderUnknownArchitecture = Nieznana architektura
#
# plik/ElfProgramHeader.java
#
ProgHeaderNotFound = Nagłówek programu nie został znaleziony.
ProgHeaderReadError = Błąd odczytu nagłówka programu.
ProgHeaderSizeError = Niedopasowanie rozmiaru nagłówka programu.
ProgHeaderSuccess = Sukces
#
# file/ElfSectionHeader.java
#
ElfSectHeadMultiStringtabError = Znaleziono wiele tabel łańcuchowych, w tej chwili nieobsługiwanych.
ElfSectHeadMultiSymtabError = Znaleziono wiele tabel symboli, w tej chwili nie obsługiwane;
ElfSectHeadNotFound = Nie znaleziono nagłówka sekcji.
ElfSectHeadReadError = Błąd odczytu nagłówka sekcji.
ElfSectHeadSizeError = Niedopasowanie rozmiaru w nagłówku sekcji.
ElfSectHeadStingIdxError = Błędny indeks łańcucha.
ElfSectHeadStingNotFound = Nazwa sekcji nie została znaleziona.
ElfSectHeadStingReadError = Błędna tabela łańcuchów do odczytu.
ElfSectHeadStingTypeError = Błąd typu łańcucha.
ElfSectHeadSuccess = Sukces
ElfSymTableNotFound = Nie udało się znaleźć tabeli symboli.
ElfSymTableReadError = Nie udało się odczytać tabeli symboli.
#
# file/ProcessorReadElf.java
#
ProcReadElf64BitNotSupportedYet = Logisim nie obsługuje jeszcze 64-bitowych plików elf.
ProcReadElfArchError = Plik elf jest przeznaczony dla procesora \"%s\", podczas gdy powinien być przeznaczony dla procesora \"%s\".
ProcReadElfEndianMismatch = niedopasowanie endowskie, plik elf jest dla procesora \"%s\", podczas gdy procesor zażądał \"%s\".
ProcReadElfErrorOpeningFile = Brak możliwości otwarcia pliku elf.
ProcReadElfLoadableSectionNotFound = Sekcja ładowalna nie znaleziona w pliku elf.
ProcReadElfLoadableSectionReadError = Błąd odczytu części ładowalnej.
ProcReadElfLoadableSectionSectionError = Błąd odczytu części, którą można załadować.
ProcReadElfLoadableSectionTooBig = Rozmiar części ładowalnej jest większy niż rozmiar obsługiwany przez logisim.
ProcReadElfMemoryError = Wystąpił błąd podczas zapisywania ładowalnej sekcji do pamięci.\nMake sure you have a SOC memory component available for the memory region:\n%s...%s
ProcReadElfNotExecutable = Plik elf-file nie jest plikiem wykonywalnym.
ProcReadElfSuccess = Sukces
#
# gui/AssemblerPanel.java
#
AsmPanAmsFileExtention = pliki montażowe (.asm,.S)
AsmPanAssemble = Złożenie kodu (ALT-A)
AsmPanDocumentChangedSave = W twoim dokumencie są zmiany, zapisać je?
AsmPanErrorCreateFile = Nie można utworzyć pliku zespołu.
AsmPanErrorReadingFile = Nie można odczytać pliku.
AsmPanNextError = Skok do następnego błędu (CTRL-N)
AsmPanOpenFile = Odczyt pliku (CTRL-L)
AsmPanPreviousError = Skok do poprzedniego błędu (CTRL-P)
AsmPanReadAsmFile = Wybierz plik do odczytu
AsmPanRun = Uruchom kod (ALT-R)
AsmPanSaveAsmFile = Wybierz plik do zapisania
AsmPanSaveFile = Zapisz plik (CTRL-S)
AsmPanSaveFileAs = Zapisz plik jako
AsmPanSaveFirstBeforeOpen = W twoim dokumencie są zmiany \nCzy chcesz je zapisać przed otwarciem nowego pliku?
AssemblerAssembleSuccess = Sukces! \NNie znaleziono żadnych błędów w kodzie.
AssemblerRunSuccess = Udane załadowanie programu do pamięci.\n Aby uruchomić program, upewnij się, że:\na) włączyłeś tyki,\nb) ustawiłeś cpu w tryb pracy
AssemblerUnableToDownload = Nie można zapisać programu w pamięci, upewnij się, że masz wystarczającą ilość dostępnej pamięci w odpowiednich miejscach pamięci.
RV32imAsmLineIndicator = Linia %d z %d
#
# gui/BreakpointPanel.java
#
RV32imRemoveBreakPoint = Usuń punkt złamania
RV32imSetBreakpoint = Dodaj punkt przerwania
#
# Gui/BusTransactionInsertionGui.java
#
SocTransInsAddress = adres autobusu: 0x
SocTransInsAtomicRequest = transakcja atomowa
SocTransInsByteAccess = transakcja bajtowa
SocTransInsHalfWordAccess = Transakcja półsłowa (2 bajty)
SocTransInsInputData = Dane do zapisu: 0x
SocTransInsInsertTransaction = Włóż transakcję do magistrali
SocTransInsManual = włożony ręcznie
SocTransInsReadData = Dane zwrócone:
SocTransInsReadRequest = żądanie odczytu z magistrali
SocTransInsTransResultTitle = Wynik włożonej transakcji:
SocTransInsWordAccess = Transakcja słowna (4 bajty)
SocTransInsWriteRequest = żądanie zapisu na magistrali
#
# gui/CpuDrawSupport.java
#
Rv32imAsmInstruction = Montaż:
Rv32imBinInstruction = Opcode:
Rv32imEmptyTrace = Brak dostępnych śladów wykonania
Rv32imExecutionTrace = Śledzenie wykonania (ostatnio wykonane na górze):
Rv32imRegisterFile = Plik rejestracyjny:
#
# gui/SocCPUShape.java
#
RV32ShapeSimControl = Sterowanie symulacyjne
#
# jtaguart/JtagUart.java
#
JtagUartClearKeyb = Czysta klawiatura
JtagUartKeybAvailable = dostępne dane z klawiatury
JtagUartKeybData = Dane z klawiatury
JtagUartKeybReadEnable = Włączenie odczytu z klawiatury
JtagUartTtyClear = TTY clear
JtagUartTtyData = dane TTY
JtagUartTtyWrite = dane do zapisu TTY
SocJtagUartComponent = składnik Jtag Uart
#
# jtaguart/JtagUartAttributes.java
#
JtagSize1024 = 1k
JtagSize128 = 128
JtagSize16 = 16
JtagSize16384 = 16k
JtagSize2048 = 2k
JtagSize256 = 256
JtagSize32 = 32
JtagSize32768 = 32k
JtagSize4096 = 4k
JtagSize512 = 512
JtagSize64 = 64
JtagSize8 = 8
JtagSize8192 = 8k
JtagUartReadIrq Próg odczytu = Próg odczytu IRQ
JtagUartWriteIrqThreshold = Próg zapisu IRQ
UartJtagREADFifoSize = Odczytaj rozmiar FIFO:
UartJtagWriteFifoSize = Zapisz rozmiar FIFO:
#
# memory/SocMemory.java
#
SocMemBase = Baza:
SocMemoryComponent = Symulator pamięci
SocMemSizeStr = Rozmiar:
#
# memory/SocMemoryAttributes.java
#
SocMemSize = Szerokość adresu bajtowego:
SocMemStartAddress = Adres początkowy:
#
# nios2/Nios2.java
#
Nios2A = A
Nios2B = B
Nios2C = C
Nios2Component = symulator Nios2s
Nios2Dataa = Dane A
Nios2Datab = Dane B
Nios2Done = Gotowe
Nios2N = N
Nios2ReadRa = Read Ra
Nios2ReadRb = Przeczytaj Rb
Nios2Result = Rezultat
Nios2Start = Start
Nios2WriteRc = Write Rc
Rv32imClockInput = wejście zegara
Rv32imIrqInput = wejście IRQ %s
Rv32imResetInput = Wejście resetowania
#
# nios2/Nios2Attributes.java
#
nios2BreakVector = Break Vector
rv32ExceptionVector = Wektor wyjątku
rv32imIrqWidth = Liczba linii IRQ
rv32ResetVector = Resetowanie wektora
rv32StateVisable = Stan widoczny:
#
# nios2/Nios2CustomInstructions.java
#
AssemblerExpectedFourArguments = Oczekiwane cztery argumenty
Nios2DonePinError = Zrobiony pin nie zdefiniowany lub w stanie błędu nie może być kontynuowany.\n Proszę sprawdzić zrobiony pin.
#
# nios2/Nios2DataTransferInstructions.java
#
LoadStoreErrorInReadTransaction = Błąd podczas wczytywania danych z systemu pamięci:
LoadStoreErrorInWriteTransaction = Błąd wykonania zapisu do systemu pamięci:
#
# nios2/Nios2OtherControlInstructions.java
#
AssemblerExpectedImmediateValue = Oczekiwana wartość natychmiastowa
AssemblerExpectedNoArguments = Oczekiwany brak argumentów
AssemblerExpected OneArgument = Oczekiwany jeden argument
AssemblerExpectedTwoArguments = Oczekiwane dwa argumenty
AssemblerExpectedZeroOrOneArgument = Oczekiwany brak lub jeden argument
AssemblerImmediateOutOfRange = Bezpośrednia wartość jest poza zakresem
AssemblerUnknownRegister = Nieznany rejestr
Nios2AssemblerExpectedBracketedRegister = Spodziewany rejestrator wspornikowy, np. (r1)
Nios2AssemblerExpectedImmediateIndexedRegister = Oczekiwany natychmiastowy indeksowany rejestr, np. 5(r1)
Nios2CannotUseControlRegister = W tym kontekście nie można używać rejestru kontrolnego.
Nios2CannotUseCustomRegister = W tym kontekście nie można korzystać z rejestru niestandardowego.
Nios2ExpectedControlRegister = Oczekiwany rejestr kontroli (np. ctl4)
#
# nios2/Nios2ProgramControlInstructions.java
#
AssemblerExpectedThreeArguments = Oczekiwane trzy argumenty
AssemblerExpextedImmediateOrLabel = Oczekiwana wartość natychmiastowa lub etykieta
#
# nios2/Nios2State.java
#
Nios2Bstatus = bstatus
Nios2Estatus = estatus
Nios2Status = status
RV32imBreakPointReached = Wykonanie jest wstrzymywane z powodu punktu przerwania ustawionego w bieżącej instrukcji.
RV32imFetchExecutionError = Błąd w wykonaniu pobranej instrukcji.
RV32imFetchInvalidInstruction = Nieważne instrukcje pobierane
RV32imFetchInvInstrAsm = Nieważne instrukcje!
RV32imFetchTransaction = -> Fetch transaction error.
Rv32imProgramCounter = pc:
SocHiddenForFasterSimulation = Zawartość ukryta dla szybszej symulacji
#
# nios2/Nios2Support.java
#
AssemblerExpectedRegister = Oczekiwany rejestr
#
# pio/PioAttributes.java
#
SicPioIrqType = typ Irq:
SocPioAnyEdge = Dowolna krawędź
SocPioBidir = dwukierunkowe (trójstanowiskowe) porty
SocPioCaptureEdge = typ przechwytywania:
SocPioDirection = Kierunek:
SocPioFallingEdge = Spadająca krawędź
SocPioGenIRQ = IRQ włączony:
SocPioInout = oba porty wejściowe i wyjściowe
SocPioInputCaptureBit = przechwytywanie bitów czyszczących:
SocPioInputOnly = Tylko porty wejściowe
SocPioInputsSyncCapture = Sync. capture:
SocPioIrQEdge = Edge
SocPioIrqLevel = Poziom
SocPioOutputIndividualBits = Bit wyjściowy ustawiony/wyczyść:
SocPioOutputOnly = Tylko porty wyjściowe
SocPioOutputResetValue = wartość resetowania wyjścia:
SocPioRisingEdge = Wznoszące się zbocze
#
# pio/PioMenu.java
#
ErrorCreatingHeaderAndOrCFile = Nie można utworzyć nagłówka i/lub pliku c!
ExportC = Eksportuj szablony C
PioMenuBidirFunctionsRemark = /* Za pomocą następujących funkcji można ustawić lub odczytać rejestr dwukierunkowy * a 1 oznacza, że szacunek. bit jest wyjściem, a 0 oznacza, że jest wejściem \n * Uwaga: używane są tylko dolne bity %s.\n */
PioMenuCaptureAll = usuń wszystkie bity w rejestrze przechwytywania niezależnie od wartości parametru "value".
PioMenuCaptureAny = co najmniej jedna zmiana z 0 na 1 lub z 1 na 0
PioMenuCaptureBit = skasuj bity w rejestrze przechwytywania, które wynoszą 1 w parametrze "wartość".
PioMenuCaptureFalling = co najmniej jedna zmiana z 1 na 0
PioMenuCaptureRising = co najmniej jedna zmiana z 0 na 1
PioMenuEdgeCaptureRemark = /* Za pomocą następujących funkcji można wyczyścić lub odczytać rejestr zbocza, jeśli rejestr zbocza jest odczytywany a 1 na pozycji wskazuje, że odpowiednie wejście ma hat %s,\n * w przeciwnym razie odpowiednie wejście nie zmieni się.\n * \n * Zapisanie do tego rejestru będzie oznaczać %s.\n * Uwaga: używane są tylko dolne bity %s.\n */
PioMenuInputDataFunctionRemark = /* Za pomocą następującej funkcji wartości wejściowe PIO mogą być \n * odczytywane.\n * Funkcja ta zwraca odpowiednią wartość \n * Uwaga: tylko dolne bity %s są ważne \n */
PioMenuIrqEdge = odpowiedni bit w rejestrze przechwytywania
PioMenuIrqLevel = odpowiednie wejście
PioMenuMaskFunctionsRemark = /* Za pomocą następujących funkcji można ustawić lub odczytać rejestr maski przerwania.\n * A 1 w określonej lokalizacji wskazuje, że przerwanie zostanie wygenerowane \n * jeśli %s jest równe 1.\n * Uwaga: używane są tylko niższe bity %s.\n */
PioMenuOutClearRemark = /* Za pomocą następującej funkcji bity o wartości 1 w parametrze "wartość" wymuszą \n * odpowiednie wyjście do 0\n * Uwaga: stosowane są tylko bity o wartości niższej %s.\n */
PioMenuOutputDataFunctionRemark = /* Za pomocą następującej funkcji wartości wyjściowe PIO mogą być \n * ustawione.\n * Funkcja ta przyjmuje nową wartość wyjściową jako parametr "wartość"\n * Uwaga: tylko dolne bity %s podanego parametru "wartość" są ważne \n */
PioMenuOutSetSetRemark = /* Za pomocą następującej funkcji bity o wartości 1 w parametrze "wartość" wymuszą \n * odpowiednie wyjście do 1 \n * Uwaga: stosowane są tylko bity o niższej wartości %s.\n */
SelectDirectoryToStoreC = Ustaw katalog do przechowywania szablonów C
SuccesCreatingHeaderAndCFile = Udane utworzenie plików:\n%s\noraz\n%s
#
# pio/SocPio.java
#
SocPioBidirPinx = Bidir bit %s
SocPioBidirs = bolce dwukierunkowe
SocPioComponent = ekspander równoległy wejścia/wyjścia
SocPioInputPinx = Bit wejściowy %s
SocPioInputs = piny wejściowe
SocPioIrqOutput = wyjście Irq
SocPioOutputPinx = Bit wyjściowy %s
SocPioOutputs = piny wyjściowe
SocPioResetInput = Wejście resetowania
#
# rv32im/Rv32im_riscv.java
#
Rv32imComponent = symulator Risc V IM
#
# rv32im/RV32imControlTransferInstructions.java
#
Rv32imAssemblerExpected OneOrTwoArguments = Oczekiwany jeden lub dwa argumenty
Rv32imAssemblerExpectedTwoOrThreeArguments = Oczekiwane dwa lub trzy argumenty
#
# rv32im/RV32imEnvironmentCallAndBreakpoints.java
#
Rv32imECABNotImplmented = Obecnie nie wdrożono zaproszenia do składania wniosków w zakresie ochrony środowiska i punktów krytycznych.
#
# rv32im/RV32imIntegerRegisterImmediateInstructions.java
#
RV32imAssemblerBUG = BUG!
#
# rv32im/RV32imLoadAndStoreInstructions.java
#
RV32imAssemblerExpectedBracketedRegister = Spodziewany rejestrator z uchwytem, np. (x1)
RV32imAssemblerExpectedImmediateIndexedRegister = Oczekiwany natychmiastowy indeksowany rejestr, np. 5(x1)
#
# rv32im/Rv32imMemoryOrderingInstructions.java
#
RV32imAssemblerNotSupportedYet = nieobsługiwany kod operacji asm
Rv32imMOINotImplmented = Obecnie instrukcje zamawiania pamięci nie są zaimplementowane.
#
# Soc.java
#
SocBusComponent = symulator magistrali SOC
socLibrary = komponenty System On Chip
#
# use/AbstractAssembler.java
#
AssemblerUnknownOpcode = Nieznany kod operacji
NieznanaInstrukcja = Nieznana instrukcja
#
# use/Assembler.java
#
AssemblerAssumingEntryPoint = Zakładając najniższy adres z instrukcją jako punkt wejścia.\nAby upewnić się, że twój cpu zaczyna wykonywać program pod właściwym adresem, dodaj etykietę '_start' w miejscu, w którym twój cpu powinien zacząć wykonywać program.
AssemblerCannotUseInsideMacro = Ta konstrukcja nie może być użyta wewnątrz definicji makra
AssemblerEndOfMacroNotFound = Nie mógł znaleźć końca definicji makro
AssemblerExpectedMacroName = oczekiwana nazwa makro
AssemblerExpectedMacroNrOfParameters = Oczekiwana liczba parametrów makro
AssemblerExpectingLabelIdentifier = Oczekujący etykiety
AssemblerMissingLabelBefore = Dla tego operatora powinna być etykieta
AssemblerNoExecutableSection = Nie znaleziono instrukcji, które można by wykonać.
AssemblerReguiresNumberAfterMath = Po operacji matematycznej powinna nastąpić liczba
AssemblerUnknowCharacter = Nieznany znak
AssemblerWrongClosingBracket = Ten wspornik zamykający nie jest obsługiwany
AssemblerWrongOpeningBracket = Ten wspornik otwierający nie jest obsługiwany
#
# use/AssemblerAsmInstruction.java
#
AssemblerCouldNotFindAddressForLabel = Nie można ustalić adresu dla tej etykiety.
AssemblerCouldNotFindValueForDefine = Nie można znaleźć definicji tego parametru.
AssemblerDivZero = dzielenie przez zero błędów
AssemblerExpectedImmediateValueAfterMath = Oczekiwana wartość natychmiast po operacji matematycznej
#
# use/AssemblerInfo.java
#
AssemblerDuplicatedLabelNotSupported = nazwy etykiet muszą być unikalne, można znaleźć wiele definicji tej etykiety
AssemblerDuplicatedName = Nie można użyć tej samej nazwy dla .equ i etykiety
AssemblerDuplicatedSectionError = nazwy sekcji muszą być unikalne, należy znaleźć wiele sekcji o tej nazwie
AssemblerExpectedLabel = Oczekiwana etykieta
AssemblerExpectedLabelAndNumber = oczekiwana etykieta, po której następuje natychmiastowa wartość
AssemblerExpectedParameter = Oczekiwany parametr na tej pozycji
AssemblerExpectingNumber = Oczekiwana liczba
AssemblerExpectingPositiveNumber = Oczekiwana liczba dodatnia
AssemblerExpectingSectionName = Oczekujący nazwy dla tej sekcji
AssemblerExpectingString = Oczekiwany łańcuch
AssemblerMacroIncorrectNumberOfParameters = Nieprawidłowa liczba określonych parametrów makro
AssemblerOverlappingSections = Ta sekcja pokrywa się z inną sekcją
AssemblerUnknownIdentifier = nie znam tego identyfikatora
AssemblerUnknownLabel = Ta etykieta nie została zdefiniowana, dlatego nie mogę jej używać
AssemblerUnsupportedAssemblerInstruction = Ta instrukcja nie jest znana.
AssemblerValueOutOfRange = Wartość jest poza zakresem
#
# use/AssemblerMacro.java
#
AssemblerMacroCallingEachotherDeadlock = Makra wywołują się wzajemnie powodując sytuację impasu
AssemblerMacroCannotUseRecurency = Makro dzwoni do siebie powodując sytuację zastoju
AssemblerMacroParameterNotDefined = Ten parametr makro nie jest zdefiniowany, sprawdź liczbę parametrów w definicji makra.
#
# vga/SocVgaShape.java
#
SocVgaComponent = ekran VGA
#
# vga/VgaAttributes.java
#
VgaBufferAddress = Adres bufora pikseli:
VgaInitialDisplayMode = Tryb początkowy:
VgaMode1024x768 = 1024x768
VgaMode160x120 = 160x120
VgaMode320x240 = 320x240
VgaMode640x480 = 640x480
VgaMode800x600 = 800x600
VgaSoft1024x768 = Oprogramowanie 1024x768:
VgaSoft160x120 = Oprogramowanie 160x120:
VgaSoft320x240 = Oprogramowanie 320x240:
VgaSoft640x480 = Oprogramowanie 640x480:
VgaSoft800x600 = Oprogramowanie 800x600:
VgaStartAddress = Adres bazowy:
#
# vga/VgaMenu.java
#
VgaMenuModeSelectFunctions = /* Za pomocą następujących funkcji można manipulować trybem vga.\n * Odczytywanie trybu vga zwraca obsługiwane tryby (patrz powyższe definicje możliwych trybów)\n * Zapisanie obsługiwanego trybu spowoduje zmianę trybu wyświetlania wyświetlacza VGA \n */


