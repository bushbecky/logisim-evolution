#
# arith/Adder.java
#
adderCarryInTip = \u00dcbertragseingang: wenn 1 wird eine weitere 1 zur Summe addiert
adderCarryOutTip = \u00dcbertragsausgang: ist 1, wenn die Summe die verf\u00fcgbare Bitbreite \u00fcbersteigt
adderComponent = Addierer
adderInputTip = Eingang: einer der Summanden
adderOutputTip = Ausgang: die Summe der Eing\u00e4nge (plus \u00dcbertragseingang)
#
# arith/Arithmetic.java
#
arithmeticLibrary = Arithmetik
#
# arith/BitAdder.java
#
bitAdderComponent = Bit-Z\u00e4hler
bitAdderInputTip = Eingang: die zu z\u00e4hlenden Bits
bitAdderOutputManyTip = Ausgang: die Anzahl der 1-Bits an den Eing\u00e4ngen
gateInputsAttr = Anzahl der Eing\u00e4nge
#
# arith/BitFinder.java
#
bitFinderComponent = Bit-Finder
bitFinderFindLabel = find
bitFinderHighLabel = high
bitFinderHighOption = Oberste %s
bitFinderIndexHighTip = Index: Index der h\u00f6chstwertigsten %s des Eingangs
bitFinderIndexLowTip = Index: Index der niederwertigsten %s des Eingangs
bitFinderInputTip = Eingang: die zu durchsuchenden Bits
bitFinderLowLabel = low
bitFinderLowOption = Unterste %s
bitFinderPresentTip = Gefunden: ist 1, wenn der Eingang eine %s enth\u00e4lt
bitFinderTypeAttr = Type
#
# arith/Comparator.java
#
comparatorComponent = Komparator
comparatorEqualTip = Gleich: ist 1, wenn A gleich B ist
comparatorGreaterTip = Gr\u00f6\u00dfer: ist 1, wenn A gr\u00f6\u00dfer als B ist
comparatorInputATip = A: die Zahl vor dem Vergleichsoperator
comparatorInputBTip = B: die Zahl nach dem Vergleichsoperator
comparatorLessTip = Kleiner: ist 1, wenn A kleiner als B ist
comparatorType = Zahlentyp
twosComplementOption = Zweierkomplement
unsignedOption = ohne Vorzeichen
#
# arith/Divider.java
#
dividerComponent = Teiler
dividerDividendLowerTip = Dividend (unten): die untere H\u00e4lfte der zu teilenden Zahl
dividerDividendUpperTip = Dividend (oben): die obere H\u00e4lfte der zu teilenden Zahl
dividerDivisorTip = Divisor: die Zahl, durch die zu teilen ist
dividerOutputTip = Ausgang: das Ergebnis der Division von Dividend durch Divisor
dividerRemainderOutput = rem
dividerRemainderTip = Rest: der Rest der Division (Dividend - Ausgang * Divisor)
dividerUpperInput = upper
#
# arith/Multiplier.java
#
multiplierCarryInTip = \u00dcbertragseingang: zum Ergebnis zu addierender Wert
multiplierCarryOutTip = \u00dcbertragsausgang: die h\u00f6herwertigen Bits des Produkts
multiplierComponent = Multiplizierer
multiplierInputTip = Eingang: eine der zu multiplizierenden Zahlen
multiplierOutputTip = Ausgang: das Produkt der Eing\u00e4nge plus \u00dcbertragseingang
#
# arith/Negator.java
#
negatorComponent = Negator
negatorInputTip = Eingang: die zu negierende Zahl
negatorOutputTip = Ausgang: das Zweierkomplement des Eingangs
#
# arith/Shifter.java
#
shiftArithmeticRight = Arithmetisch nach rechts
shifterComponent = Bitschieber
shifterDistanceTip = Distanz: wie weit der Eingang zu schieben ist
shifterInputTip = Eingang: die zu schiebenden Bits
shifterOutputTip = Ausgang: Ergebnis der Schiebung des Eingangs
shifterShiftAttr = Schiebertyp
shiftLogicalLeft = Logisch nach links
shiftLogicalRight = Logisch nach rechts
shiftRollLeft = Rotieren nach links
shiftRollRight = Rotieren nach rechts
#
# arith/Subtractor.java
#
subtractorBorrowInTip = Leiheingang: wenn 1 wird eine weitere 1 vom Ergebnis abgezogen
subtractorBorrowOutTip = Leihausgang: ist 1, wenn die Differenz ngativ ist
subtractorComponent = Subtrahierer
subtractorMinuendTip = Minuend: die Zahl, von der abzuziehen ist
subtractorOutputTip = Ausgang: die Differenz zwischen Minuend und Subtrahend
subtractorSubtrahendTip = Subtrahend: die Zahl, die abgezogen wird
#
# base/Base.java
#
baseLibrary = Basis
#
# base/Text.java
#
textComponent = Beschriftung
textFontAttr = Zeichensatz
textHorzAlignAttr = Horizontale Ausrichtung
textHorzAlignCenterOpt = Zentriert
textHorzAlignLeftOpt = Links
textHorzAlignRightOpt = Rechts
textTextAttr = Text
textVertAlignAttr = Vertikale Ausrichtung
textVertAlignBaseOpt = Basis
textVertAlignBottomOpt = Unten
textVertAlignCenterOpt = Zentriert
textVertAlignTopOpt = Oben
#
# base/VhdlParser.java
#
CannotFindEntityException = Die Entit\u00e4tserkl\u00e4rung kann nicht gefunden werden.
emptySourceException = Leere Inhalte k\u00f6nnen nicht analysiert werden.
genericDeclarationException = Syntax illegaler Generika
genericTypeException = Nicht unterst\u00fctzter Generikatyp
genericValueException = Standardwert f\u00fcr nicht erkannte Generika
invalidTypeException = Ung\u00fcltiger Porttyp
portDeclarationException = Illegale Port-Syntax
#
# Builtin.java
#
builtinLibrary = Eingebaut
#
# gates/AndGate.java
#
andGateComponent = AND Gatter
#
# gates/Buffer.java
#
bufferComponent = Puffer
#
# gates/ControlledBuffer.java
#
controlledBufferComponent = Tristate-Puffer
controlledControlOption = Position der Steuerleitung
controlledInverterComponent = Tristate-Inverter
controlledLeftHanded = linke Seite
controlledRightHanded = rechte Seite
#
# gates/EvenParityGate.java
#
evenParityComponent = Gerade Parit\u00e4t
#
# gates/GateAttributes.java
#
gateOutput01 = 0/1
gateOutput0Z = 0/hochohmig
gateOutputAttr = Ausgabewert
gateOutputZ1 = hochohmig/1
gateSizeNormalOpt = Mittel
xorBehaviorAttr = Verhalten bei mehreren Eing\u00e4ngen
xorBehaviorOdd = Falls eine ungerade Anzahl gesetzt ist
xorBehaviorOne = Falls genau ein Eingang gesetzt ist
#
# gates/Gates.java
#
gatesLibrary = Gatter
#
# gates/NandGate.java
#
nandGateComponent = NAND Gatter
#
# gates/NegateAttribute.java
#
gateNegateAttr = Negiere %s
#
# gates/NorGate.java
#
norGateComponent = NOR Gatter
#
# gates/NotGate.java
#
gateSizeAttr = Gattergr\u00f6\u00dfe
gateSizeNarrowOpt = Schmal
gateSizeWideOpt = Breit
notGateComponent = Inverter
#
# gates/OddParityGate.java
#
oddParityComponent = Ungerade Parit\u00e4t
#
# gates/OrGate.java
#
orGateComponent = OR Gatter
#
# gates/PLA.java
#
Bit Width In = Bitbreite in
Bit Width Out = Bitbreite aus
input = Input
output = Output
PLA = PLA
plaClickToEdit = (zum Bearbeiten anklicken)
plaEditMenuItem = PLA-Programm bearbeiten......
plaProgram = Programm
#
# gates/PLATable.java
#
plaEditorTitle = PLA-Programmeditor
plaFileCreateError = Es konnte keine Datei erstellt werden.
plaFileOpenError = Die Datei konnte nicht ge\u00f6ffnet werden.
plaLoadDialogTitle = PLA-Programm laden
plaLoadErrorTitle = Fehler beim Laden des PLA-Programms
plaSaveDialogTitle = PLA-Programm speichern
plaSaveErrorTitle = Fehler beim Speichern des PLA-Programms
#
# gates/XnorGate.java
#
xnorGateComponent = XNOR Gatter
#
# gates/XorGate.java
#
xorGateComponent = XOR Gatter
#
# InstanceComponent.java
#
KeywordNameError = Label ist ein reserviertes Schl\u00fcsselwort und kann nicht verwendet werden. Bitte geben Sie ein anderes Etikett an.
MatchedLabelNameError = Label und Komponentenname sind m\u00f6glicherweise nicht identisch (Gro\u00df-/Kleinschreibung wird nicht beachtet). Bitte geben Sie ein anderes Label als den Komponentennamen an.
#
# InstanceTextField.java
#
changeLabelAction = Beschriftung \u00e4ndern
#
# io/Button.java
#
buttonComponent = Taster
#
# io/DipSwitch.java
#
DIP = DIP
DipSwitchComponent = Dip-Schalter
nrOfSwitch = Anzahl der Schalter
#
# io/DotMatrix.java
#
ioInputColumn = Spalten
ioInputRow = Zeilen
ioInputSelect = Zeilen / Spalten ausw\u00e4hlen
ioMatrixCols = Matrixspalten
ioMatrixInput = Eingabeformat
ioMatrixPersistenceAttr = Nachleuchtdauer
ioMatrixRows = Matrixzeilen
ioMatrixShape = Punktform
ioShapeCircle = Rund
ioShapeSquare = Quadratisch
#
# io/extra/Buzzer.java
#
buzzerComponent = Summer
buzzerFrequecy = H\u00e4ufigkeit
buzzerVolume = Volumen
buzzerVolumeBitWidth = Volumenbitbreite
dHz (0.1Hz) = dHz (0,1Hz)
enableSound = Ton aktivieren
Hz = Hz
#
# io/extra/DigitalOscilloscope.java
#
BorderColor = Randfarbe
bothOption = beide
ClearDiagram = \u00dcbersichtliches Diagramm
DigitalOscilloscopeClock = Uhr
DrawClockFrontLine = Uhr an der Frontlinie zeichnen
noOption = keine
ShowClockAttribute = Uhrattribut anzeigen
stdTriggerFalling = Fallende Flanke
stdTriggerRising = Steigende Flanke
#
# io/extra/ITA_IO.java
#
DigitalOscilloscopeComponent = digitale Oszillation
Slider = Schieberegler
#
# io/extra/PlaRom.java
#
memCSTip = Chip-Auswahl: 0 deaktiviert das Bauteil
PlaANDAttr = Und
PlaOutputsAttr = Output
PlaRomComponent = 
ramCSLabel = sel
#
# io/extra/PlaRomData.java
#
PlaEditWindowTitel = Pla Rom %s Bearbeitungsfenster
#
# io/extra/PlaRomPanel.java
#
demultiplexerInTip = Eingang
multiplexerOutTip = Ausgang
#
# io/extra/ProgrammableGenerator.java
#
NStateAttr = Anzahl der Staaten
#
# io/extra/ProgrammableGeneratorState.java
#
ProgrammableGeneratorComponent = Progr. Generator
#
# io/extra/Slider.java
#
left_to_rightOption = von links nach rechts
right_to_leftOption = von rechts nach links
#
# io/extra/Switch.java
#
switchComponent = Schalter
#
# io/HexDigit.java
#
hexDigitDataTip = Daten: Nibble zur Darstellung in hexadezimaler Darstellung
hexDigitDPTip = Dezimalpunkt: Leuchtet das Dezimalpunkt.
#
# io/HexDigitShape.java
#
hexDigitComponent = Hexadezimale Anzeige
#
# io/Io.java
#
dipswitchComponent = Dip-Schalter
dotMatrixComponent = LED-Matrix
ioActiveAttr = Eingeschaltet bei H-Signal?
ioBackgroundColor = Hintergrund
ioColorAttr = Farbe
ioLibrary = Eingabe/Ausgabe
ioOffColor = Farbe AUS
ioOnColor = Farbe AN
joystickComponent = Joystick
#
# io/Joystick.java
#
ioBitWidthAttr = Bitbreite
#
# io/Keyboard.java
#
keybAvailTip = Verf\u00fcgbar: 1 wenn der Puffer Zeichen enth\u00e4lt
keybBufferLengthAttr = Pufferl\u00e4nge
keybClearTip = L\u00f6schen: wenn 1 wird der Puffer gel\u00f6scht
keybClockTip = Takt: Triggersignal entfernt das vorderste Zeichen des Puffers
keybDesc = Tastatur (Pufferkap. %s)
keybEnableTip = Lesefreigabe: 0 sperrt das Taktsignal
keyboardComponent = Tastatur
keybOutputTip = Daten: ASCII-Wert des vordersten Zeichens im Puffer
#
# io/Led.java
#
ledComponent = LED
#
# io/PortIO.java
#
pioBuses = Ein oder mehrere Busse
pioComponent = Port I/O
pioNumber = Anzahl der PIN
pioPins = Einzelstift
pioShowBus = Verbindungstyp ?
#
# io/ReptarLocalBus.java
#
repLBComponent = Reptar Lokaler Bus
repLBTip = B-Spitze
#
# io/RGBLed.java
#
BLUE = Blauer Eingang
GREEN = Gr\u00fcner Eingang
RED = Roter Eingang
RGBledComponent = RGBLED
#
# io/SevenSegment.java
#
DecimalPoint = Dezimalpunkt
Segment_A = Segment A
Segment_B = Segment B
Segment_C = Segment C
Segment_D = Segment D
Segment_E = Segment E
Segment_F = Segment F
Segment_G = Segment G
sevenSegmentComponent = 7-Segmentanzeige
#
# io/Tty.java
#
ttyClearTip = L\u00f6schen: 1 l\u00f6scht den Bildschirm
ttyClockTip = Takt: Triggersignal \u00fcbernimmt das Zeichen vom Eingang
ttyColsAttr = Spalten
ttyComponent = Terminal
ttyDesc = Terminal (%s Zeilen, %s Spalten)
ttyDescShort = Terminal
ttyEnableTip = Schreibfreigabe: 0 sperrt das Taktsignal
ttyInputTip = Daten: ASCII-Wert des n\u00e4chsten zu schreibenden Zeichens
ttyRowsAttr = Zeilen
#
# io/Video.java
#
rgbVideoCLK = Uhr
rgbVideoColor = Farbmodell
rgbVideoComponent = RGB-Video
rgbVideoCursor = Cursor
rgbVideoData = Daten im %s-Format
rgbVideoHeight = H\u00f6he
rgbVideoReset = Verhalten zur\u00fccksetzen
rgbVideoRST = Zur\u00fccksetzen
rgbVideoScale = Skala
rgbVideoWE = Schreibfreigabe
rgbVideoWidth = Breite
rgbVideoX = X-Koordinate
rgbVideoY = Y-Koordinate
#
# library/bcd2sevenseg.java
#
BCD Value = BCD-Wert
BCD2SevenSegment = BCD auf sieben Segmente
#
# library/BFHPraktika.java
#
BFH mega functions = BFH Mega-Funktionen
#
# library/bin2bcd.java
#
Bin2BCD = Binairy zu BCD
Binairy data bits = Binairy-Datenbits
BinairyInputTip = Binairy-Eingabe
#
# memory/AbstractFlipFlop.java
#
flipFlopClockTip = Takt: Zustandsaktualisierung bei Triggersignal
flipFlopNotQTip = Aktuellen Flip-Flop-Zustand invertieren
flipFlopPresetTip = Setzen: wenn 1, gehe asynchron zu Zustand 1
flipFlopQTip = Aktueller Flip-Flop-Zustand
flipFlopResetTip = L\u00f6schen: wenn 1, gehe asynchron zu Zustand 0
#
# memory/Counter.java
#
counterCarryTip = \u00dcbertrag: ist 1, wenn der Z\u00e4hler den H\u00f6chstwert erreicht (Minimalwert beim Abw\u00e4rtsz\u00e4hlen)
counterClockTip = Takt: Wert kann bei Triggersignal aktualisiert werden
counterDataTip = Daten: in den Z\u00e4hler zu ladender Wert
counterEnableLabel = ct
counterEnableTip = Takt: wenn 1, z\u00e4hle aufw\u00e4rts (oder abw\u00e4rts falls Laden = 1)
counterGoalAttr = Bei \u00dcberlauf:
counterGoalContinue = Z\u00e4hle weiter
counterGoalLoad = Lade den n\u00e4chsten Wert
counterGoalStay = Halte an
counterGoalWrap = Starte neu
counterLabel = ctr
counterLoadTip = Laden: wenn 1, lade den Wert vom Daten-Eingang (falls Takt = 0) oder z\u00e4hle abw\u00e4rts
counterMaxAttr = H\u00f6chstwert
counterQTip = Ausgang: aktueller Wert des Z\u00e4hlers
counterResetTip = L\u00f6schen: wenn 1 wird der Z\u00e4hler asynchron auf 0 gesetzt
counterUpDownTip = Aufw\u00e4rts Abw\u00e4rts: wenn 1, Z\u00e4hler erh\u00f6ht, wenn 0, Z\u00e4hler verringert sich.
registerWidthLabel = (%sb)
#
# memory/JKFlipFlop.java
#
jkFlipFlopComponent = J-K Flip-Flop
#
# memory/Mem.java
#
ByteLabel = Byte
GigabyteLabel = Gbyte
KilobyteLabel = kByte
MegabyteLabel = MByte
ramAddrLabel = A
ramAddrWidthAttr = Bitbreite der Adresse
ramDataWidthAttr = Bitbreite der Daten
ramSelAttr = Ausw\u00e4hlen
stdTriggerHigh = H-Niveau
stdTriggerLow = L-Niveau
#
# memory/MemMenu.java
#
ramClearMenuItem = Inhalt l\u00f6schen
ramConfirmClearMsg = Sind SIe sicher, da\u00df der Speicher auf Null gesetzt werden soll?
ramConfirmClearTitle = L\u00f6schen best\u00e4tigen
ramEditMenuItem = Inhalt bearbeiten ...
ramLoadDialogTitle = Lade RAM-Abbild
ramLoadErrorTitle = Fehler beim Laden
ramLoadMenuItem = Speicherabbild laden...
ramSaveDialogTitle = Speichere RAM-Abbild
ramSaveErrorTitle = Fehler beim Speichern
ramSaveMenuItem = Speicherabbild speichern...
#
# memory/Memory.java
#
counterComponent = Z\u00e4hler
dFlipFlopComponent = D Flip-Flop
memoryLibrary = Speicher
ramComponent = RAM
randomComponent = Zufallsgenerator
registerComponent = Register
#
# memory/Ram.java
#
ramBusTip = Daten: geladener oder zu speichernder Wert
ramClkTip = Takt: Speicherinhalt wird beim \u00dcbergang von 0 auf 1 aktualisiert
ramContentsAttr = Erste Inhalte
ramDataLabel = D
ramInTip = Eingang: an der Adresse zu speichernder Wert
ramOELabel = ld
ramOETip = Laden: wenn 1 wird Speicherinhalt auf Ausgang \u00fcbertragen
ramWELabel = str
ramWETip = Speichern: wenn 1 wird Eingang in Speicher \u00fcbertragen
#
# memory/RamAttributes.java
#
ramBidirDataBus = Ein bidirektionaler Datenbus
ramByteEnables = Leseschreibsteuerung
ramDataAttr = Datenbus-Implementierung
ramNoByteEnables = Nur Lesen/Schreiben von ganzen W\u00f6rtern
ramSeparateDataBus = Separater Datenbus f\u00fcr Lesen und Schreiben
ramWithByteEnables = Byte verwenden aktiviert
#
# memory/Random.java
#
randomClockTip = Takt: Wert kann bei Triggersignal aktualisiert werden
randomLabel = zuf\u00e4llig
randomNextTip = Freigabe: wechsle zum n\u00e4chsten Schritt der Sequenz bei Triggersignal
randomQTip = Ausgang: aktuelle Zahl in der Zahlenfolge
randomResetTip = L\u00f6schen: wenn 1 wird asynchron auf den urspr\u00fcnglichen Startwert zur\u00fcckgesetzt
randomSeedAttr = Startwert
randomWidthLabel = Breite: %d
#
# memory/Register.java
#
registerClkTip = Takt: Wert wird bei Triggersignal aktualisiert
registerClrTip = L\u00f6schen: wenn 1 wird der Wert asynchron auf 0 gesetzt
registerDTip = Daten: beim Triggersignal zu speichernder Wert
registerEnableTip = Freigabe: wenn 0 sind Taktsignale unwirksam
registerLabel = reg
registerQTip = Ausgang: aktueller Wert des Registers
registerShowInTab = In Registerkarten anzeigen
#
# memory/Rom.java
#
memAddrTip = Adresse: Zugriffsposition im Speicher
memDataTip = Daten: von der Adresse geladene Daten
romComponent = ROM
romContentsAttr = Inhalt
romContentsValue = (Klicken zum Bearbeiten)
#
# memory/RomContentsListener.java
#
romChangeAction = ROM-Inhalt bearbeiten
#
# memory/ShiftRegister.java
#
shiftRegClearTip = L\u00f6schen: wenn 1 werden alle Werte asynchron auf 0 gesetzt
shiftRegClockTip = Takt: Werte k\u00f6nnen bei Triggersignal aktualisiert werden
shiftRegInTip = Eingang: Wert, der in die erste Stufe geschoben werden soll
shiftRegisterLabel1 = shift reg
shiftRegisterLabel2 = %sx%s
shiftRegLengthAttr = Anzahl der Stufen
shiftRegLoadTip = Laden: wenn 1 (mit Freigabe = 0) werden alle Stufen von den Eing\u00e4ngen geladen
shiftRegOutTip = Ausgang: der Inhalt der letzten Stufe
shiftRegParallelAttr = Paralleles Laden
shiftRegShiftTip = Freigabe: wenn 0 ist das Schieben gesperrt
#
# memory/ShiftRegisterLogger.java
#
shiftRegisterComponent = Schieberegister
#
# memory/SRFlipFlop.java
#
srFlipFlopComponent = S-R Flip-Flop
#
# memory/TFlipFlop.java
#
tFlipFlopComponent = T Flip-Flop
#
# plexers/BitSelector.java
#
bitSelectorDataTip = Eingang
bitSelectorGroupAttr = Ausgangsbits
bitSelectorOutputTip = Ausgang: Wert der ausgew\u00e4hlten Gruppe von Bits vom Eingang
bitSelectorSelectTip = Auswahl: gibt an, welche Gruppe von Bits ausgew\u00e4hlt werden soll
#
# plexers/Decoder.java
#
decoderComponent = Dekoder
decoderEnableTip = Aktivierung: wenn nicht 0, wird 1 auf ausgew\u00e4hlten Ausgang geschaltet
decoderOutTip = Ausgang %s
decoderSelectTip = Auswahl: gibt an, welcher Ausgang auf 1 gesetzt wird
#
# plexers/Demultiplexer.java
#
demultiplexerComponent = Demultiplexer
demultiplexerEnableTip = Aktivierung: wenn nicht 0, wird Eingang auf ausgew\u00e4hlten Ausgang geschaltet
demultiplexerSelectTip = Auswahl: gibt an, an welchen Ausgang der Eingang durchgeschaltet wird
#
# plexers/Multiplexer.java
#
multiplexerComponent = Multiplexer
multiplexerEnableTip = Aktivierung: wenn nicht 0 wird ausgew\u00e4hlter Eingang auf Ausgang geschaltet
multiplexerSelectTip = Auswahl: gibt an, welcher Eingang an den Ausgang durchgeschaltet wird
#
# plexers/Plexers.java
#
bitSelectorComponent = Bit-W\u00e4hler
plexerDisabledAttr = Disabled Output
plexerDisabledFloating = Offen
plexerDisabledZero = Null
plexerEnableAttr = Enable Eingang?
plexerLibrary = Auswahlschaltungen
plexerSelectBitsAttr = Auswahlleitungen
plexerSelectBottomLeftOption = Unten/Lonks
plexerSelectLocAttr = Position der Eing\u00e4nge
plexerSelectTopRightOption = Oben/Rechts
plexerThreeStateAttr = Threestate?
#
# plexers/PriorityEncoder.java
#
priorityEncoderComponent = Priorit\u00e4tsenkoder
priorityEncoderEnableOutTip = Freigabeausgang: 1 wenn freigegeben und kein Eingang auf 1 gesetzt
priorityEncoderGroupSignalTip = Gruppenauswahl: 1 wenn einer der Eing\u00e4nge auf 1 gesetzt
priorityEncoderInTip = Eingang %s
priorityEncoderOutTip = Ausgang: Adresse des h\u00f6chst-indizierten, auf 1 gesetzten Eingangs
#
# StdAttr.java
#
ioLabelColorAttr = Farbe der Beschriftung
stdClassicAppearance = Klassisches Logisim
stdDataWidthAttr = Datenbits
stdEvolutionAppearance = Logisim-HolyCross
stdFacingAttr = Ausrichtung
stdLabelAttr = Beschriftung
stdLabelCenter = Zentrum
stdLabelFontAttr = Zeichensatz der Beschriftung
stdLabelLocAttr = Etikettenposition
stdLabelVisibility = Etikett sichtbar
stdLogisimEvolutionAppearance = Logisim-Entwicklung
stdTriggerAttr = Trigger
#
# tcl/Tcl.java
#
tclGeneric = TCL generisch
tclLibrary = TCL
#
# tcl/TclComponentAttributes.java
#
tclConsoleContentFile = TCL Inhaltsdatei
#
# tcl/TclConsoleReds.java
#
tclConsoleReds = TCL REDS Konsole
#
# tcl/TclGeneric.java
#
tclInterfaceDefinition = TCL-Schnittstelle VHDL-Einheit
tclInterfaceDefinitionValue = (zum Bearbeiten anklicken)
#
# ttl/AbstractTtlGate.java
#
demultiplexerOutTip = Ausgang %s
GNDPin = Erdungsstift %s
multiplexerInTip = Eingang %s
VCCPin = VCC-Pin %s
#
# ttl/DisplayDecoder.java
#
BI = BI
BlankingInputInTip = Ausblendung
DisplayDecoderComponent = Display-Decoder
DisplayDecoderInTip = Input
DisplayDecoderOutTip = Output
ioMultiBit = Multi-Bit
LampTestInTip = Eingang Lampentest
LT = LT
memEnableLabel = en
priorityEncoderEnableInTip = Freigabeeingang: 0 sperrt das Bauteil
RBI = RBI
RippleBlankingInputInTip = Ripple Blanking Eingang
#
# ttl/TTL.java
#
ShowInternalStructure = Zeigt die interne Struktur an
TTL7400 = 7400: Vierfach 2-Eingangs-NAND-Gate mit 2 Eing\u00e4ngen
TTL7402 = 7402: Vierfach-NOR-Gatter mit 2 Eing\u00e4ngen
TTL7404 = 7404: Hex-Wechselrichter
TTL7408 = 7408: Quad 2-Eing\u00e4nge UND Gate
TTL7410 = 7410: dreifacher 3-Eingangs-NAND-Gate mit 3 Eing\u00e4ngen
TTL7411 = 7411: dreifach 3-Eing\u00e4nge UND Gate
TTL74125 = 74125: Quad-Bus-Puffer, Drei-Status-Ausg\u00e4nge, negative Freigabe
TTL7413 = 7413: Duales 4-Eingangs-NAND-Gate (Schmitt-Trigger)
TTL7414 = 7414: Hex-Wechselrichter (Schmitt-Trigger)
TTL74165 = 74165: 8-Bit Parallel-Serielles Schieberegister mit 8 Bit
TTL74175 = 74175: quad D-Flipflop, asynchroner Reset
TTL7418 = 7418: Duales 4-Eingangs-NAND-Gate (Schmitt-Trigger)
TTL7419 = 7419: Hex-Wechselrichter (Schmitt-Trigger)
TTL7420 = 7420: Duales 4-Eingangs-NAND-Gate mit 4 Eing\u00e4ngen
TTL7421 = 7421: Dual 4-Eing\u00e4nge UND Gate
TTL7424 = 7424: vier 2-Eing\u00e4nge NAND-Gatter (Schmitt-Trigger)
TTL74266 = 74266: Vierfach XNOR-Gate mit 2 Eing\u00e4ngen
TTL7427 = 7427: dreifacher 3-Eingangs-NOR-Gate mit 3 Eing\u00e4ngen
TTL74273 = 74273: oktaler D-Flipflop mit transparentem Rand
TTL74283 = 74283: 4-Bit-Bin\u00e4r-Volladdierer f\u00fcr Bin\u00e4rdateien
TTL7430 = 7430: einzelnes NAND-Gate mit 8 Eing\u00e4ngen
TTL7432 = 7432: Vierfach 2-Eing\u00e4nge ODER-Gatter
TTL7436 = 7436: Vierfach-NOR-Gatter mit 2 Eing\u00e4ngen
TTL74377 = 74377: oktaler D-Flipflop mit Freigabe
TTL7442 = 7442: BCD auf Dezimaldecoder
TTL7443 = 7443: Excess-3 bis Dezimaldecoder
TTL7444 = 7444: Grauer bis dezimaler Decoder
TTL7447 = 7447: BCD zu 7-Segment Decoder
TTL7451 = 7451: Dual AND-OR-INVERT-Gate
TTL7454 = 7454: Vier breite UND-OR-INVERT-Tore
TTL7458 = 7458: Dual AND-OR Gatter
TTL7464 = 7464: 4-2-3-2-2 AND-OR-INVERT Gate
TTL7474 = 7474: zwei D-Flipflops mit Preset und Clear
TTL7485 = 7485: 4-Bit Gr\u00f6\u00dfenvergleicher
TTL7486 = 7486: Vierfach XOR-Gatter mit 2 Eing\u00e4ngen
VccGndPorts = Vcc- und Gnd-Ports aktivieren
#
# wiring/BitExtender.java
#
extenderComponent = Bit-Erweiterung
extenderInAttr = Bitbreite
extenderInputLabel = Eingang
extenderInputType = Eingang
extenderMainLabel = erweitern
extenderOneLabel = 1
extenderOneType = Eins
extenderOutAttr = Bitbreite Aus
extenderSignLabel = Vorzeichen
extenderSignType = Vorzeichen
extenderTypeAttr = Art der Erweiterung
extenderZeroLabel = 0
extenderZeroType = Null
#
# wiring/Clock.java
#
clockComponent = Takt
clockHighAttr = Dauer H-Signal
clockLowAttr = Dauer L-Signal
#
# wiring/Constant.java
#
constantComponent = Konstante
constantValueAttr = Wert
#
# wiring/DoNotConnect.java
#
noConnectionComponent = Nicht anschlie\u00dfen
#
# wiring/DurationAttribute.java
#
clockDurationOneValue = 1 Takt
clockDurationValue = %s Takte
durationLargeMessage = Wert darf h\u00f6chstens %s sein.
durationSmallMessage = Wert mu\u00df mindestens %s sein.
freqInvalidMessage = Wert ist nicht ganzzahlig
PORDurationOneValue = 1 Sek
PORDurationValue = %s Secs Secs
#
# wiring/Ground.java
#
groundComponent = Masse
#
# wiring/Pin.java
#
PinCancel = Abbrechen
pinComponent = Pin
PinEnterDecimal = Dezimalzahl eingeben
pinFrozenQuestion = Der Pin ist mit dem Zustand der h\u00f6heren Ebene verkn\u00fcpft. Einen neuen Schaltungszustand erstellen?
pinFrozenTitle = Der Pin ist in der h\u00f6heren Ebene zugeordnet.
pinInputName = Eingang
pinInputToolTip = Eingangspin hinzuf\u00fcgen
PinOkay = OK
pinOutputAttr = Ausgang?
pinOutputName = Ausgang
pinOutputToolTip = Ausgangspin hinzuf\u00fcgen
pinPullAttr = Pull-Verhalten
pinPullDownOption = Pull-Down
pinPullNoneOption = Unver\u00e4ndert
pinPullUpOption = Pull-Up
pinThreeStateAttr = Threestate?
#
# wiring/PowerOnReset.java
#
porHighAttr = POR-Zeit
PowerOnResetComponent = POR
#
# wiring/Probe.java
#
probeComponent = Testpunkt
#
# wiring/ProbeAttributes.java
#
probeNewPin = Pfeilformen
stdAppearanceAttr = Aussehen
#
# wiring/PullResistor.java
#
pullComponent = Pull-Widerstand
pullErrorType = Fehler
pullOneType = Eins
pullTypeAttr = Pull-Richtung
pullZeroType = Null
#
# wiring/Transistor.java
#
transistorComponent = Transistor
transistorNDrain = Drain: eine niedrige Quelle zieht den Drain nach unten (nur wenn das Gate hoch ist).
transistorNGate = Gate: wenn hoch, l\u00e4sst der Strom durch den Transistor flie\u00dfen.
transistorNSource = Quelle: eine niedrige Quelle zieht den Drain niedrig (nur wenn das Gate hoch ist).
transistorPDrain = Drain: eine hohe Quelle zieht den Drain nach oben (nur wenn das Gate niedrig ist).
transistorPGate = Gate: wenn niedrig, l\u00e4sst der Strom durch den Transistor flie\u00dfen.
transistorPSource = Quelle: eine hohe Quelle zieht den Drain hoch (nur wenn das Gate niedrig ist).
transistorTypeAttr = Type
transistorTypeN = N-Type
transistorTypeP = P-Type
#
# wiring/TransmissionGate.java
#
transmissionGateComponent = \u00dcbertragungsgatter
transmissionGateDrain = Ablauf: quellengesteuert, abh\u00e4ngig von p-Gate und n-Gate
transmissionGateNGate = n-gate: wenn niedrig, l\u00e4sst die niedrige Quelle durch, um die Entw\u00e4sserung zu erreichen.
transmissionGatePGate = p-gate: wenn hoch, l\u00e4sst es zu, dass eine hohe Quelle durchstr\u00f6mt und abflie\u00dft.
transmissionGateSource = Quelle: steuert den Abfluss, abh\u00e4ngig von p-gate und n-gate
#
# wiring/Tunnel.java
#
tunnelComponent = Tunnel
#
# wiring/Wiring.java
#
powerComponent = Versorgungsspannung
wiringGateAttr = Position der Eing\u00e4nge
wiringGateBottomRightOption = Unten/Rechts
wiringGateTopLeftOption = Oben/Links
wiringLibrary = Verdrahtung


