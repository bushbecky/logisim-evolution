#
# bus/SocBus.java
#
SocBusComponent = SOC-Bus-Simulator
#
# bus/SocBusAttributes.java
#
SocBusTraceSize = Leiterbahngr\u00f6\u00dfe:
SocBusTraceVisable = Spuren sichtbar:
#
# bus/SocBusMenuProvider.java
#
insertTrans = Einf\u00fcgen einer Bustransaktion
SocBusMemMap = Speicherkarte anzeigen
SocBusTraceWindow = Bustransaktion(en) Trace anzeigen
SocInsertTransWindowTitle = F\u00fcgen Sie eine Transaktion auf dem Bus ein:
TraceWindowTitleDoubleClickOnTraceToRemoveTrace = Bus-Trace-Fenster (Doppelklick auf eine Trace, um sie zu entfernen)
#
# data/SocBusInfo.java
#
SocBusNotConnected = Nicht an einen Bus angeschlossen
#
# data/SocBusStateInfo.java
#
SocBusNoTrace = Keine Spuren vorhanden
SocMemMapWindowTitle = Speicherabbildung f\u00fcr den Bus:
SocMemoryMapOk = Schlie\u00dfen
SocMemoryMapTitle = Memory Map (rot zeigt \u00fcberlappende Speicherbereiche an):
#
# data/SocBusTransaction.java
#
SocBusStateMaster = Initiator:
SocBusStateNoDataMax10chars = keine Daten
SocBusStateSlave = Responder:
SocBusStateTraceIndex = Transaktion Nr....:
SocTransactionByteAccesNoSupport = Der Slave unterst\u00fctzt keine Bytezugriffe.
SocTransactionByteAccesNoSupportShort = Kein Bytezugriff
SocTransactionHalfWordAccesNoSupport = Der Slave unterst\u00fctzt keine Halbwortzugriffe.
SocTransactionHalfWordAccesNoSupportShort = Kein HW-Zugang
SocTransactionMisallignedAddress = Der Slave hat eine falsch ausgerichtete Adresse erkannt.
SocTransactionMisallignedAddressShort = Misal. Adressat
SocTransactionMultipleSlaveAnswers = Mehrere Slaves antworteten auf eine Transaktion. Bitte \u00fcberpr\u00fcfen Sie die Speicherkarte Ihrer Slaves.
SocTransactionMultipleSlaveAnswersShort = Mehrere Slaves
SocTransactionNoBusConnected = Die Master-Komponente ist nicht an einen Soc-Bus angeschlossen. Bitte verbinden Sie den Master mit einer Buskomponente.
SocTransactionNoBusConnectedShort = Kein Bus
SocTransactionNoneAtomicRW = Eine atomare Lese-/Schreibaktion wird nicht angefordert. Dies ist nicht erlaubt.
SocTransactionNoneAtomicRWShort = Kein Atom RW
SocTransactionNoRespons = Keine Slave-Komponente antwortete auf die Anfrage. Bitte \u00fcberpr\u00fcfen Sie die Speicheradresse der Anforderung und die Speicherkarte Ihres Systems.
SocTransactionNoResponsShort = Keine Antwort
SocTransactionNoSlavesAttached = Der Bus, der mit dem Master verbunden ist, hat keine Slaves angeschlossen. Bitte verbinden Sie einige Slaves mit dem Bus.
SocTransactionNoSlavesAttachedShort = Keine Sklaven
SocTransactionReadOnlyAccessError = Der Slave unterst\u00fctzt nur Lesezugriffe auf diese Adresse.
SocTransactionReadOnlyAccessErrorShort = Nur Lesen
SocTransactionRegisterDoesNotExist = Der Slave unterst\u00fctzt keinen Zugriff auf diese Adresse.
SocTransactionRegisterDoesNotExistShort = Kein Zugriff
SocTransactionSuccessfull = Es ist kein Fehler aufgetreten, die Transaktion ist erfolgreich.
SocTransactionSuccessfullShort = Erfolg
SocTransactionUnknownError = Seltsam, diese Fehlermeldung sollte nie auftreten und stellt einen Fehler in logisim dar.
SocTransactionUnknownErrorShort = BUG!
SocTransactionWordAccesNoSupport = Der Slave unterst\u00fctzt keine Wortzugriffe.
SocTransactionWordAccesNoSupportShort = Kein Wortzugriff
SocTransactionWriteOnlyAccessError = Der Slave unterst\u00fctzt keine Lesevorgang an dieser Adresse.
SocTransactionWriteOnlyAccessErrorShort = Nur Schreiben
#
# data/SocMemMapModel.java
#
SocMemMapEmpty = Leer (keine Slaves)
SocMemMapEndAddress = Endadresse:
SocMemMapSlaveName = Name der Komponente:
SocMemMapStartAddress = Startadresse:
#
# data/SocSimulationManager.java
#
SocBusManagerSelectBus = Bitte w\u00e4hlen Sie einen Bus aus, mit dem Sie sich verbinden m\u00f6chten.
SocBusSelectAttr = Angeschlossener Bus
SocBusSelectAttrClick = Klicken Sie hier, um auszuw\u00e4hlen
SocManagerNoBusses = Keine Busse verf\u00fcgbar, bitte f\u00fcgen Sie einen SOC-Bus zu Ihrem Schaltplan hinzu.
#
# data/SocUpMenuProvider.java
#
ProcReadElfLoadedAndEntrySet = Die Elf-Datei wurde erfolgreich in den Speicher geladen.\nDer Einstiegspunkt der ausf\u00fchrbaren Datei wurde auf den Prozessor gesetzt.\n\nWichtig:\n   Da die Elf-Datei keine Informationen \u00fcber die Ausnahmevektoren hat.\n   Du musst sie selbst kontrollieren!
SocUpMenuAsmWindow = Assembler \u00f6ffnen
SocUpMenuCpuAsmWindowTitle = Assembler f\u00fcr CPU :
SocUpMenuCpuProgramWindowTitle = disassembler f\u00fcr cpu :
SocUpMenuCpuStateWindowTitle = prozessorzustand f\u00fcr cpu :
SocUpMenuErrorReadingElfTitle = Fehler beim Lesen der Elf-Datei
SocUpMenuReadElf = Elf-Datei lesen
SocUpMenuSelectElfFile = Elf-Datei zum Importieren ausw\u00e4hlen
SocUpMenuShowProgram = Geladenes Programm anzeigen
SocUpMenuShowState = CPU-Status anzeigen
#
# data/SocUpSimulationState.java
#
SocUpSimHalt = Angehalten
SocUpSimHaltBreak = Haltepunkt
SocUpSimHaltError = Fehler
SocUpSimRunning = Laufen
SocUpSimStateLabel = Sim-Zustand:
SocUpSimstateStart = Start
SocUpSimstateStop = Pause
SocUpUnknown = Unbekannt
#
# file/ElfHeader.java
#
ElfHeaderEIClassError = Keine 32- oder 64-Bit-Elf-Datei
ElfHeaderEIDataError = Nicht eine kleine oder gro\u00dfe endianisch kodierte Datei.
ElfHeaderIncorrectEISize = Die Gr\u00f6\u00dfe f\u00fcr den EI-Abschnitt ist falsch.
ElfHeaderIncorrectESize = Die Gr\u00f6\u00dfe f\u00fcr den E-Profil ist falsch.
ElfHeaderIncorrectMagic = Die Datei enth\u00e4lt nicht die richtige elf-magic; wahrscheinlich keine elf-Datei.
ElfHeaderNoErrors = Kopf ist korrekt
ElfHeaderReadingFileError = Fehler beim Lesen der Datei
ElfHeaderUnknownArchitecture = Unbekannte Architektur
#
# file/ElfProgramHeader.java
#
ProgHeaderNotFound = Programmkopf nicht gefunden.
ProgHeaderReadError = Fehler beim Lesen des Programmkopfes.
ProgHeaderSizeError = Gr\u00f6\u00dfenabweichung im Programmkopf.
ProgHeaderSuccess = Erfolg
#
# file/ElfSectionHeader.java
#
ElfSectHeadMultiStringtabError = Es wurden mehrere Stringtabellen gefunden, die im Moment nicht unterst\u00fctzt werden.
ElfSectHeadMultiSymtabError = Es wurden mehrere Symboltabellen gefunden, die im Moment nicht unterst\u00fctzt werden;
ElfSectHeadNotFound = Abschnitts\u00fcberschrift nicht gefunden.
ElfSectHeadReadError = Fehler beim Lesen der Abschnitts\u00fcberschrift.
ElfSectHeadSizeError = Gr\u00f6\u00dfenabweichung in der Abschnitts\u00fcberschrift.
ElfSectHeadStingIdxError = Fehler Zeichenkettenindex.
ElfSectHeadStingNotFound = Abschnittsname nicht gefunden.
ElfSectHeadStingReadError = Fehler beim Lesen der Stringtabelle.
ElfSectHeadStingTypeError = Zeichenkettentypfehler.
ElfSectHeadSuccess = Erfolg
ElfSymTableNotFound = Die Symboltabelle konnte nicht gefunden werden.
ElfSymTableReadError = Die Symboltabelle konnte nicht gelesen werden.
#
# file/ProcessorReadElf.java
#
ProcReadElf64BitNotSupportedYet = Logisim unterst\u00fctzt noch keine 64-Bit-Elf-Dateien.
ProcReadElfArchError = Die Elf-Datei ist f\u00fcr einen "%s" Prozessor, w\u00e4hrend sie f\u00fcr einen "%s" Prozessor sein sollte.
ProcReadElfEndianMismatch = Endianische Diskrepanz, die Elfendatei ist "%s", w\u00e4hrend der Prozessor nach"%s" gefragt hat.
ProcReadElfErrorOpeningFile = Elf-Datei kann nicht ge\u00f6ffnet werden
ProcReadElfLoadableSectionNotFound = Ladbarer Abschnitt nicht in der Elf-Datei gefunden.
ProcReadElfLoadableSectionReadError = Fehler beim Lesen des ladbaren Abschnitts.
ProcReadElfLoadableSectionSizeError = Gr\u00f6\u00dfenabweichung im belastbaren Abschnitt.
ProcReadElfLoadableSectionTooBig = Die Gr\u00f6\u00dfe des ladbaren Abschnitts ist gr\u00f6\u00dfer als die von logisim unterst\u00fctzte Gr\u00f6\u00dfe.
ProcReadElfMemoryError = Es ist ein Fehler beim Schreiben eines ladbaren Abschnitts in den Speicher aufgetreten.\nStellen Sie sicher, dass Sie eine SOC-Speicherkomponente f\u00fcr den Speicherbereich zur Verf\u00fcgung haben:\n%s....%s
ProcReadElfNotExecutable = Die elf-Datei ist keine ausf\u00fchrbare Datei.
ProcReadElfSuccess = Erfolg
#
# gui/AssemblerPanel.java
#
AsmPanAmsFileExtention = Assembly-Dateien (.asm,.S)
AsmPanAssemble = Den Code zusammensetzen (ALT-A)
AsmPanDocumentChangedSave = Es gibt \u00c4nderungen in Ihrem Dokument, speichern Sie sie?
AsmPanErrorCreateFile = Es ist nicht m\u00f6glich, die Assembly-Datei zu erstellen.
AsmPanErrorReadingFile = Die Datei konnte nicht gelesen werden.
AsmPanNextError = Zum n\u00e4chsten Fehler springen (STRG-N)
AsmPanOpenFile = Eine Datei lesen (STRG-L)
AsmPanPreviousError = Zum vorherigen Fehler springen (STRG-P)
AsmPanReadAsmFile = W\u00e4hlen Sie eine Datei zum Lesen aus
AsmPanRun = Den Code ausf\u00fchren (ALT-R)
AsmPanSaveAsmFile = W\u00e4hlen Sie eine Datei zum Speichern aus
AsmPanSaveFile = Datei speichern (STRG-S)
AsmPanSaveFileAs = Datei speichern unter
AsmPanSaveFirstBeforeOpen = Es gibt \u00c4nderungen in Ihrem Dokument.\nM\u00f6chten Sie sie speichern, bevor Sie eine neue Datei \u00f6ffnen?
AssemblerAssembleSuccess = Erfolgreich!\nEs wurden keine Fehler in Ihrem Code gefunden.
AssemblerRunSuccess = Das Programm wurde erfolgreich in den Speicher geladen.\nUm das Programm auszuf\u00fchren, stellen Sie bitte sicher, dass es funktioniert:\na) du aktivierst die Ticks\nb) Sie stellen die CPU in den Betriebsmodus.
AssemblerUnableToDownload = Das Programm kann nicht im Speicher gespeichert werden,\nBitte stellen Sie sicher, dass Sie gen\u00fcgend Speicherplatz zur Verf\u00fcgung haben.\nan den richtigen Speicherpl\u00e4tzen.
#
# gui/BreakpointPanel.java
#
RV32imAsmLineIndicator = Zeile %d von %d
RV32imRemoveBreakPoint = Haltepunkt entfernen
RV32imSetBreakpoint = Haltepunkt hinzuf\u00fcgen
#
# gui/BusTransactionInsertionGui.java
#
SocTransInsAddress = Busadresse: 0x
SocTransInsAtomicRequest = Atomare Transaktion
SocTransInsByteAccess = Byte-Transaktion
SocTransInsHalfWordAccess = Halbworttransaktion (2 Bytes)
SocTransInsInputData = Daten zum Schreiben: 0x
SocTransInsInsertTransaction = F\u00fcgen Sie die Transaktion in den Bus ein.
SocTransInsManual = Manuell eingelegt
SocTransInsReadData = Daten wurden zur\u00fcckgegeben:
SocTransInsReadRequest = Bus-Leseanforderung
SocTransInsTransResultTitle = Ergebnis der eingef\u00fcgten Transaktion:
SocTransInsWordAccess = Word-Transaktion (4 Bytes)
SocTransInsWriteRequest = Bus-Schreibanforderung
#
# gui/CpuDrawSupport.java
#
Rv32imAsmInstruction = Montage:
Rv32imBinInstruction = Opcode:
Rv32imEmptyTrace = Keine Ausf\u00fchrungsspuren verf\u00fcgbar
Rv32imExecutionTrace = Ausf\u00fchrungs-Trace (zuletzt oben ausgef\u00fchrt):
Rv32imProgramCounter = St\u00fcck
Rv32imRegisterFile = Datei registrieren:
#
# gui/SocCPUShape.java
#
RV32ShapeSimControl = Simulationssteuerung
#
# jtaguart/JtagUart.java
#
JtagUartClearKeyb = Tastatur l\u00f6schen
JtagUartKeybAvailable = Tastaturdaten verf\u00fcgbar
JtagUartKeybData = Keyboard-Daten
JtagUartKeybReadEnable = Lesefreigabe der Tastatur
JtagUartTtyClear = TTY klar
JtagUartTtyData = TTY-Daten
JtagUartTtyWrite = TTY schreibt Daten
Rv32imClockInput = Takteingang
Rv32imResetInput = Reset-Eingang
SocJtagUartComponent = Jtag Uart Komponente
SocPioIrqOutput = Irq-Ausgang
#
# jtaguart/JtagUartAttributes.java
#
JtagSize1024 = 1k
JtagSize128 = 128
JtagSize16 = 16
JtagSize16384 = 16k
JtagSize2048 = 2k
JtagSize256 = 256
JtagSize32 = 32
JtagSize32768 = 32k
JtagSize4096 = 4k
JtagSize512 = 512
JtagSize64 = 64
JtagSize8 = 8
JtagSize8192 = 8k
JtagUartReadIrqThreshold = IRQ-Schwellenwert lesen
JtagUartWriteIrqThreshold = Schreiben des IRQ-Schwellenwerts
UartJtagREADFifoSize = FIFO-Gr\u00f6\u00dfe lesen:
UartJtagWriteFifoSize = Schreiben Sie die FIFO-Gr\u00f6\u00dfe:
VgaStartAddress = Basisadresse:
#
# memory/SocMemory.java
#
SocMemBase = Basis:
SocMemSizeStr = Gr\u00f6\u00dfe:
#
# memory/SocMemoryAttributes.java
#
SocMemSize = Breite der Byte-Adresse:
SocMemStartAddress = Startadresse:
#
# nios2/Nios2.java
#
Nios2A = A
Nios2B = B
Nios2C = C
Nios2Component = Nios2s Simulator
Nios2Dataa = Daten A
Nios2Datab = Daten B
Nios2Done = Erledigt
Nios2N = N
Nios2ReadRa = Lesen Sie Ra
Nios2ReadRb = Rb lesen
Nios2Result = Ergebnis
Nios2Start = Start
Nios2WriteRc = Schreiben Sie Rc
#
# nios2/Nios2Attributes.java
#
nios2BreakVector = Bruchvektor
#
# nios2/Nios2CustomInstructions.java
#
AssemblerExpectedFourArguments = Erwartete vier Argumente
Nios2DonePinError = Ein nicht definierter oder im Fehlerzustand befindlicher Pin kann nicht fortgesetzt werden.\n Bitte \u00fcberpr\u00fcfen Sie den fertigen Pin.
#
# nios2/Nios2OtherControlInstructions.java
#
AssemblerExpectedZeroOrOneArgument = Erwartet kein oder ein Argument
Nios2AssemblerExpectedBracketedRegister = Erwartet ein eingeklammertes Register, z.B. (r1)
Nios2AssemblerExpectedImmediateIndexedRegister = Erwartet ein sofort indiziertes Register, z.B. 5(r1)
Nios2CannotUseControlRegister = Ein Steuerregister kann in diesem Zusammenhang nicht verwendet werden.
Nios2CannotUseCustomRegister = In diesem Zusammenhang kann kein benutzerdefiniertes Register verwendet werden.
Nios2ExpectedControlRegister = Erwartet ein Steuerregister (z.B. ctl4)
#
# nios2/Nios2ProgramControlInstructions.java
#
AssemblerExpextedImmediateOrLabel = Erwarteter Sofortwert oder ein Label
#
# nios2/Nios2State.java
#
Nios2Bstatus = bstatus
Nios2Estatus = estatus
Nios2Status = Status
#
# pio/PioAttributes.java
#
SicPioIrqType = Irq-Typ:
SocPioAnyEdge = Jede Kante
SocPioBidir = Bidirektionale (tristate) Anschl\u00fcsse
SocPioCaptureEdge = Aufnahmeart:
SocPioDirection = Richtung:
SocPioFallingEdge = Fallende Kante
SocPioGenIRQ = IRQ aktiviert:
SocPioInout = Sowohl Eingangs- als auch Ausgangsports
SocPioInputCaptureBit = Erfassen Sie Bit-Reinigungen:
SocPioInputOnly = Nur Eingangsports
SocPioInputsSyncCapture = Synchronisierung. Erfassung:
SocPioIrQEdge = Kante
SocPioIrqLevel = Level
SocPioOutputIndividualBits = Ausgangsbit gesetzt/gel\u00f6scht:
SocPioOutputOnly = Nur Ausgangsports
SocPioOutputResetValue = Ausgang R\u00fccksetzwert:
SocPioRisingEdge = Steigende Kante
#
# pio/PioMenu.java
#
PioMenuBidirFunctionsRemark = /* Mit folgenden Funktionen kann das bidirektionale Register eingestellt oder ausgelesen werden\n * a 1 bedeutet, dass das Respekt-Bit ein Ausgang ist, a 0 bedeutet, dass es ein Eingang ist.\n * Hinweis: Es werden nur die unteren %s-Bits verwendet.\n */
PioMenuCaptureAll = L\u00f6schen aller Bits im Capture-Register unabh\u00e4ngig vom Wert des Parameters "value".
PioMenuCaptureAny = mindestens eine \u00c4nderung von 0 auf 1 oder von 1 auf 0
PioMenuCaptureBit = L\u00f6schen der Bits im Capture-Register, die 1 sind, im Parameter "value".
PioMenuCaptureFalling = mindestens eine \u00c4nderung von 1 auf 0
PioMenuCaptureRising = mindestens eine \u00c4nderung von 0 auf 1
PioMenuEdgeCaptureRemark = /* Mit folgenden Funktionen kann das Kantenerfassungsregister gel\u00f6scht oder ausgelesen werden\n * Falls das Kantenregister ausgelesen wird, zeigt eine 1 an einer Position an, dass die\n * Die jeweilige Eingabe hat Hut %s,\n * ansonsten hat sich der jeweilige Eingang nicht ge\u00e4ndert.\n *\n * Das Schreiben in dieses Register wird %s.\n * Hinweis: Es werden nur die unteren %s-Bits verwendet.\n */
PioMenuInputDataFunctionRemark = /* Mit der folgenden Funktion k\u00f6nnen die Eingangswerte der PIO wie folgt eingestellt werden\n * vorlesen.\n * Diese Funktion gibt den entsprechenden Wert zur\u00fcck.\n * Hinweis: Nur die unteren %s-Bits sind g\u00fcltig.\n */
PioMenuIrqEdge = entsprechendes Bit im Capture-Register
PioMenuIrqLevel = entsprechende Eingabe
PioMenuMaskFunctionsRemark = /* Mit den folgenden Funktionen kann das Interruptmaskenregister eingestellt oder ausgelesen werden.\n * Eine 1 an einer bestimmten Stelle zeigt an, dass ein Interrupt ausgel\u00f6st wird.\n * wenn %s gleich 1 ist.\n * Hinweis: Es werden nur die unteren %s-Bits verwendet.\n */
PioMenuOutClearRemark = /* Mit der folgenden Funktion erzwingen die Bits, die im Parameter "value" 1 sind, eine Kraftwirkung.\n * die entsprechende Ausgabe auf 0\n * Hinweis: Es werden nur die unteren %s-Bits verwendet.\n */
PioMenuOutputDataFunctionRemark = /* Mit der folgenden Funktion k\u00f6nnen die Ausgangswerte der PIO wie folgt eingestellt werden\n * gesetzt.\n * Diese Funktion \u00fcbernimmt den neuen Ausgabewert als Parameter "Wert".\n * Hinweis: Nur die unteren %s-Bits des angegebenen Parameters "value" sind g\u00fcltig.\n */
PioMenuOutSetRemark = /* Mit der folgenden Funktion erzwingen die Bits, die im Parameter "value" 1 sind, eine Kraftwirkung.\n * der entsprechende Ausgang zu 1\n * Hinweis: Es werden nur die unteren %s-Bits verwendet.\n */
#
# pio/SocPio.java
#
SocPioBidirPinx = Bidir-Bit %s
SocPioBidirs = Bidirektionale Pins
SocPioComponent = Parallele Ein-/Ausgangserweiterung
SocPioInputPinx = Eingangsbit %s
SocPioInputs = Eingangspins
SocPioOutputPinx = Ausgabebit %s
SocPioOutputs = Ausgangspins
SocPioResetInput = Reset-Eingang
#
# rv32im/RV32im_M_ExtensionInstructions.java
#
AssemblerExpectedRegister = Erwartet ein Register
AssemblerExpectedThreeArguments = Erwartete drei Argumente
AssemblerUnknownRegister = Unbekanntes Register
#
# rv32im/Rv32im_riscv.java
#
Rv32imComponent = Risc V IM Simulator
Rv32imIrqInput = IRQ-Eingang %s
#
# rv32im/RV32im_state.java
#
RV32imBreakPointReached = Die Ausf\u00fchrung wird aufgrund eines an der aktuellen Anweisung gesetzten Haltepunktes unterbrochen.
RV32imFetchExecutionError = Fehler bei der Ausf\u00fchrung des geholten Befehls
RV32imFetchInvalidInstruction = Ung\u00fcltige Anweisung geholt
RV32imFetchInvInstrAsm = Ung\u00fcltige Anweisung!
RV32imFetchTransaction = -> Fetch Transaktionsfehler.
SocHiddenForFasterSimulation = Versteckte Inhalte f\u00fcr eine schnellere Simulation
#
# rv32im/RV32imAttributes.java
#
rv32ExceptionVector = Ausnahmevektor
rv32imIrqWidth = Anzahl der IRQ-Leitungen
rv32ResetVector = Vektor zur\u00fccksetzen
rv32StateVisable = Zustand sichtbar:
#
# rv32im/RV32imControlTransferInstructions.java
#
AssemblerExpectedNoArguments = Erwartet keine Argumente
AssemblerExpectedOneArgument = Erwartet ein Argument
Rv32imAssemblerExpectedOneOrTwoArguments = Erwartete ein oder zwei Argumente
Rv32imAssemblerExpectedTwoOrThreeArguments = Erwartete zwei oder drei Argumente
#
# rv32im/RV32imEnvironmentCallAndBreakpoints.java
#
Rv32imECABNotImplmented = Derzeit sind die Umweltaufrufe und Haltepunkte nicht implementiert.
#
# rv32im/RV32imIntegerRegisterImmediateInstructions.java
#
RV32imAssemblerBUG = BUG!
#
# rv32im/RV32imLoadAndStoreInstructions.java
#
AssemblerExpectedImmediateValue = Erwarteter Sofortwert
AssemblerExpectedTwoArguments = Erwartete zwei Argumente
AssemblerImmediateOutOfRange = Der Sofortwert liegt au\u00dferhalb des Bereichs.
LoadStoreErrorInReadTransaction = Fehler beim Laden aus dem Speichersystem:
LoadStoreErrorInWriteTransaction = Fehler bei der Ausf\u00fchrung eines Speichers f\u00fcr das Speichersystem:
RV32imAssemblerExpectedBracketedRegister = Erwartet ein eingeklammertes Register, z.B. (x1)
RV32imAssemblerExpectedImmediateIndexedRegister = Erwartet ein sofort indiziertes Register, z.B. 5(x1)
#
# rv32im/Rv32imMemoryOrderingInstructions.java
#
RV32imAssemblerNotSupportedYet = Nicht unterst\u00fctzter ASM-Operationscode
Rv32imMOINotImplmented = Derzeit sind die Anweisungen zur Speicherbestellung nicht implementiert.
#
# Soc.java
#
socLibrary = System On Chip Komponenten
SocMemoryComponent = Speichersimulator
#
# util/AbstractAssembler.java
#
AssemblerUnknownOpcode = Unbekannter Opcode
UnknownInstruction = Unbekannter Befehl
#
# util/Assembler.java
#
AssemblerAssumingEntryPoint = Unter der Annahme der niedrigsten Adresse mit einem Befehl als Einstiegspunkt.\nUm sicherzustellen, dass Ihr CPU an der richtigen Adresse ausgef\u00fchrt wird.\nBitte f\u00fcgen Sie ein Label namens'_start' an der Stelle hinzu.\nwo Ihre CPU mit der Ausf\u00fchrung des Programms beginnen soll.
AssemblerCannotUseInsideMacro = Dieses Konstrukt kann nicht innerhalb einer Makrodefinition verwendet werden.
AssemblerEndOfMacroNotFound = Das Ende der Makrodefinition konnte nicht gefunden werden.
AssemblerExpectedMacroName = Erwarteter Name des Makros
AssemblerExpectedMacroNrOfParameters = Erwartete Anzahl der Makroparameter
AssemblerExpectingLabelIdentifier = Erwarten eines Labels
AssemblerMissingLabelBefore = F\u00fcr diesen Bediener sollte ein Etikett sein.
AssemblerNoExecutableSection = Es wurden keine Anweisungen gefunden, die ausgef\u00fchrt werden k\u00f6nnen.
AssemblerReguiresNumberAfterMath = Nach einer mathematischen Operation sollte eine Zahl folgen.
AssemblerUnknowCharacter = Unbekannter Charakter
AssemblerWrongClosingBracket = Diese Verschlusshalterung wird nicht unterst\u00fctzt.
AssemblerWrongOpeningBracket = Diese \u00d6ffnungswinkel wird nicht unterst\u00fctzt.
#
# util/AssemblerAsmInstruction.java
#
AssemblerCouldNotFindAddressForLabel = Es konnte keine Adresse f\u00fcr dieses Label ermittelt werden.
AssemblerCouldNotFindValueForDefine = Es konnte keine Definition dieses Parameters gefunden werden.
AssemblerDivZero = Teilen durch Nullpunktfehler
AssemblerExpectedImmediateValueAfterMath = Erwarteter Sofortwert nach einer mathematischen Operation
#
# util/AssemblerInfo.java
#
AssemblerDuplicatedLabelNotSupported = Labelnamen m\u00fcssen eindeutig sein, es wurden mehrere Definitionen dieses Labels gefunden.
AssemblerDuplicatedName = Kann nicht den gleichen Namen f\u00fcr ein .equ und ein Label verwenden.
AssemblerDuplicatedSectionError = Abschnittsnamen m\u00fcssen eindeutig sein, mehrere Abschnitte mit diesem Namen gefunden werden.
AssemblerExpectedLabel = Erwartet ein Label
AssemblerExpectedLabelAndNumber = Erwartet ein Label, gefolgt von einem sofortigen Wert.
AssemblerExpectedParameter = Erwartete einen Parameter an dieser Stelle
AssemblerExpectingNumber = Erwartete eine Zahl
AssemblerExpectingPositiveNumber = Erwartet eine positive Zahl
AssemblerExpectingSectionName = Erwarten eines Namens f\u00fcr diesen Abschnitt
AssemblerExpectingString = Erwartete Zeichenkette
AssemblerMacroIncorrectNumberOfParameters = Falsche Anzahl der angegebenen Makroparameter
AssemblerOverlappingSections = Dieser Abschnitt \u00fcberlappt mit einem anderen Abschnitt.
AssemblerUnknownIdentifier = Ich kenne diesen Identifikator nicht.
AssemblerUnsupportedAssemblerInstruction = Dieser Assemblerbefehl ist nicht bekannt.
AssemblerValueOutOfRange = Wert liegt au\u00dferhalb des Bereichs
#
# util/AssemblerMacro.java
#
AssemblerMacroCallingEachotherDeadlock = Makros rufen sich gegenseitig an und verursachen eine Deadlock-Situation.
AssemblerMacroCannotUseRecurency = Macro nennt sich selbst und verursacht eine Deadlock-Situation.
AssemblerMacroParameterNotDefined = Dieser Makroparameter ist nicht definiert, \u00fcberpr\u00fcfen Sie die Anzahl der Parameter in Ihrer Makrodefinition.
AssemblerUnknownLabel = Dieses Label wurde nicht definiert, daher kann ich es nicht verwenden.
#
# vga/SocVga.java
#
SocVgaComponent = VGA-Bildschirm
#
# vga/VgaAttributes.java
#
VgaBufferAddress = Pixelpuffer Adresse:
VgaInitialDisplayMode = Anfangsmodus:
VgaMode1024x768 = 1024x768
VgaMode160x120 = 160x120
VgaMode320x240 = 320x240
VgaMode640x480 = 640x480
VgaMode800x600 = 800x600
VgaSoft1024x768 = Software 1024x768:
VgaSoft160x120 = Software 160x120:
VgaSoft320x240 = Software 320x240:
VgaSoft640x480 = Software 640x480:
VgaSoft800x600 = Software 800x600:
#
# vga/VgaMenu.java
#
ErrorCreatingHeaderAndOrCFile = Es konnte keine Kopf- und/oder C-Datei erstellt werden!
ExportC = C-Vorlagen exportieren
SelectDirectoryToStoreC = Verzeichnis zum Speichern der C-Templates festlegen
SuccesCreatingHeaderAndCFile = Die Dateien wurden erfolgreich erstellt:\n%s\nund\n%s
VgaMenuModeSelectFunctions = /* Mit den folgenden Funktionen kann der VGA-Modus manipuliert werden.\n * Das Lesen des VGA-Modus gibt die unterst\u00fctzten Modi zur\u00fcck (siehe oben, definiert die m\u00f6glichen Modi).\n * Das Schreiben eines unterst\u00fctzten Modus \u00e4ndert den Anzeigemodus des VGA-Displays.\n */


