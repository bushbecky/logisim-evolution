#
# bus/SocBus.java
#
SocBusComponent = Simulador de barramento SOC
#
# bus/SocBusAttributes.java
#
SocBusTraceSize = Tamanho dos vest\u00edgios:
SocBusTraceVisable = Vest\u00edgios vis\u00edveis:
#
# bus/SocBusMenuProvider.java
#
insertTrans = Inserir uma transa\u00e7\u00e3o de \u00f4nibus
SocBusMemMap = Mostrar mapa de mem\u00f3ria
SocBusTraceWindow = Mostrar rastreamento de transa\u00e7\u00e3o(\u00f5es) de \u00f4nibus
SocInsertTransWindowTitle = Inserir uma transa\u00e7\u00e3o no \u00f4nibus:
TraceWindowTitleDoubleClickOnTraceToRemoveTrace = Bus trace window (clique duas vezes em um tra\u00e7ado para remov\u00ea-lo)
#
# data/SocBusInfo.java
#
SocBusNotConnected = N\u00e3o ligado a um autocarro
#
# data/SocBusStateInfo.java
#
SocBusNoTrace = N\u00e3o h\u00e1 vest\u00edgios presentes
SocMemMapWindowTitle = Mapa de Mem\u00f3ria para \u00f4nibus:
SocMemoryMapOk = Fechar
SocMemoryMapTitle = Mapa de Mem\u00f3ria (o vermelho indica regi\u00f5es de mem\u00f3ria sobrepostas):
#
# data/SocBusTransaction.java
#
SocBusStateMaster = Iniciador:
SocBusStateNoDataMax10chars = nenhum dado
SocBusStateSlave = Respons\u00e1vel:
SocBusStateTraceIndex = Transac\u00e7\u00e3o n\u00ba:
SocTransactionByteAccesNoSupport = Escravo n\u00e3o suporta acessos por bytes.
SocTransactionByteAccesNoSupportShort = Sem acesso a bytes
SocTransactionHalfWordAccesNoSupport = Escravo n\u00e3o suporta acessos de meia palavra.
SocTransactionHalfWordAccesNoSupportShort = Sem acesso HW
SocTransactionMisallignedAddress = O escravo detectou um endere\u00e7o desalinhado.
SocTransactionMisallignedAddressShort = Misal. Endere\u00e7o.
SocTransactionMultipleSlaveAnswers = M\u00faltiplos escravos respondidos a uma transac\u00e7\u00e3o. Por favor, verifique o mapa de mem\u00f3ria dos seus escravos.
SocTransactionMultipleSlaveAnswersShort = M\u00faltiplos escravos
SocTransactionNoBusConnected = O componente mestre n\u00e3o est\u00e1 conectado a nenhum barramento Soc. Por favor, conecte o mestre a um componente de barramento.
SocTransactionNoBusConnectedShort = Sem \u00f4nibus
SocTransactionNoneAtomicRW = Uma a\u00e7\u00e3o de leitura/grava\u00e7\u00e3o at\u00f4mica nenhuma \u00e9 solicitada. Isto n\u00e3o \u00e9 permitido.
SocTransactionNoneAtomicRWShort = Nenhum RW at\u00f3mico
SocTransactionNoRespons = Nenhum componente escravo respondeu ao pedido. Verifique o endere\u00e7o de mem\u00f3ria do pedido e o mapa de mem\u00f3ria do seu sistema.
SocTransactionNoResponsShort = Sem resposta
SocTransactionNoSlavesAttached = O bus que est\u00e1 ligado ao mestre n\u00e3o tem escravos ligados. Por favor, prendam alguns escravos ao autocarro.
SocTransactionNoSlavesAttachedShort = Sem escravos
SocTransactionReadOnlyAccessError = Escravo suporta apenas acessos de leitura neste endere\u00e7o
SocTransactionReadOnlyAccessErrorShort = Apenas leitura
SocTransactionRegisterDoesNotExist = Escravo n\u00e3o suporta nenhum acesso neste endere\u00e7o
SocTransactionRegisterDoesNotExistShort = Sem acesso
SocTransactionSuccessfull = N\u00e3o ocorreu nenhum erro, a transa\u00e7\u00e3o \u00e9 bem-sucedida.
SocTransactionSuccessfullShort = Sucesso
SocTransactionUnknownError = Bizarro, esta mensagem de erro nunca deve ocorrer e representa um bug em logisim.
SocTransactionUnknownErrorShort = BUG!
SocTransactionWordAccesNoSupport = Escravo n\u00e3o suporta acesso a palavras.
SocTransactionWordAccesNoSupportShort = Sem acesso a palavras
SocTransactionWriteOnlyAccessError = Escravo n\u00e3o suporta uma a\u00e7\u00e3o de leitura neste endere\u00e7o.
SocTransactionWriteOnlyAccessErrorShort = Escrever apenas
#
# data/SocMemMapModel.java
#
SocMemMapEmpty = Vazio (sem escravos)
SocMemMapEndAddress = Endere\u00e7o final:
SocMemMapSlaveName = Nome do componente:
SocMemMapStartAddress = Endere\u00e7o inicial:
#
# data/SocSimulationManager.java
#
SocBusManagerSelectBus = Por favor, selecione um \u00f4nibus para se conectar a
SocBusSelectAttr = Bus conectado
SocBusSelectAttrClick = Clique para selecionar
SocManagerNoBusses = N\u00e3o h\u00e1 autocarros dispon\u00edveis, por favor adicione um SOC-bus ao seu esquema
#
# data/SocUpMenuProvider.java
#
ProcReadElfLoadedAndEntrySet = Carregou com sucesso o arquivo de elfo na mem\u00f3ria.\nO ponto de entrada do execut\u00e1vel foi definido para o processador.\n\nImportante:\n   Como o arquivo do elfo n\u00e3o tem informa\u00e7\u00f5es sobre os vetores de exce\u00e7\u00e3o\n   tens de as controlar tu mesmo!
SocUpMenuAsmWindow = Assembler aberto
SocUpMenuCpuAsmWindowTitle = assembler para cpu :
SocUpMenuCpuProgramWindowTitle = desmontador para cpu :
SocUpMenuCpuStateWindowTitle = estado do processador para cpu :
SocUpMenuErrorReadingElfTitle = Erro na leitura do arquivo de elfo
SocUpMenuReadElf = Ler arquivo de elfo
SocUpMenuSelectElfFile = Selecione o arquivo de elfo para importar
SocUpMenuShowProgram = Mostrar programa carregado
SocUpMenuShowState = Mostrar estado da CPU
#
# data/SocUpSimulationState.java
#
SocUpSimHalt = Parado
SocUpSimHaltBreak = Ponto de parada
SocUpSimHaltError = Erro
SocUpSimRunning = Corrida
SocUpSimStateLabel = Estado Sim:
SocUpSimstateStart = In\u00edcio
SocUpSimstateStop = Pausa
SocUpUnknown = Desconhecido
#
# file/ElfHeader.java
#
ElfHeaderEIClassError = N\u00e3o \u00e9 um arquivo de elfo de 32 ou 64 bits
ElfHeaderEIDataError = N\u00e3o \u00e9 um pequeno ou grande arquivo codificado endian
ElfHeaderIncorrectEISize = O tamanho da sec\u00e7\u00e3o EI est\u00e1 incorrecto
ElfHeaderIncorrectESize = O tamanho da sec\u00e7\u00e3o E est\u00e1 incorrecto
ElfHeaderIncorrectMagic = O arquivo n\u00e3o cont\u00e9m o elf-magic correto; provavelmente n\u00e3o \u00e9 um arquivo de elf-magic
ElfHeaderNoErrors = O cabe\u00e7alho est\u00e1 correto
ElfHeaderReadingFileError = Erro ao ler o ficheiro
ElfHeaderUnknownArchitecture = Arquitetura desconhecida
#
# file/ElfProgramHeader.java
#
ProgHeaderNotFound = Cabe\u00e7alho do programa n\u00e3o encontrado.
ProgHeaderReadError = Erro na leitura do cabe\u00e7alho do programa.
ProgHeaderSizeError = Desencontro de tamanho no cabe\u00e7alho do programa.
ProgHeaderSuccess = Sucesso
#
# file/ElfSectionHeader.java
#
ElfSectHeadMultiStringtabError = Encontrei v\u00e1rias tabelas de strings, n\u00e3o suportadas no momento.
ElfSectHeadMultiSymtabError = Encontrei v\u00e1rias tabelas de s\u00edmbolos, n\u00e3o suportadas de momento;
ElfSectHeadNotFound = O cabe\u00e7alho da sec\u00e7\u00e3o n\u00e3o foi encontrado.
ElfSectHeadReadError = Cabe\u00e7alho da se\u00e7\u00e3o de leitura de erros.
ElfSectHeadSizeError = Desajuste de tamanho no cabe\u00e7alho da se\u00e7\u00e3o.
ElfSectHeadStingIdxError = Error String index.
ElfSectHeadStingNotFound = Nome da sec\u00e7\u00e3o n\u00e3o encontrado.
ElfSectHeadStingReadError = Erro ao ler a tabela de strings.
ElfSectHeadStingTypeError = Erro de tipo String.
ElfSectHeadSuccess = Sucesso
ElfSymTableNotFound = N\u00e3o consegui encontrar a tabela de s\u00edmbolos.
ElfSymTableReadError = N\u00e3o conseguia ler a tabela de s\u00edmbolos.
#
# file/ProcessorReadElf.java
#
ProcReadElf64BitNotSupportedYet = Logisim ainda n\u00e3o suporta arquivos de elfo de 64 bits.
ProcReadElfArchError = Arquivo de elfo \u00e9 para um processador de Elf, enquanto que deveria ser para um processador de Elf.
ProcReadElfEndianMismatch = Endian Mismatch, arquivo de elfo \u00e9 "Elf", enquanto o processador pediu "Elf".
ProcReadElfErrorOpeningFile = Imposs\u00edvel abrir o arquivo de elfo
ProcReadElfLoadableSectionNotFound = Se\u00e7\u00e3o carreg\u00e1vel n\u00e3o encontrada no arquivo do elfo.
ProcReadElfLoadableSectionReadError = Erro na leitura da se\u00e7\u00e3o carreg\u00e1vel.
ProcReadElfLoadableSectionSizeError = Desajuste de tamanho na se\u00e7\u00e3o carreg\u00e1vel.
ProcReadElfLoadableSectionTooBig = O tamanho da se\u00e7\u00e3o carreg\u00e1vel \u00e9 maior do que o tamanho suportado pelo logisim.
ProcReadElfMemoryError = Ocorreu um erro ao escrever uma sec\u00e7\u00e3o carreg\u00e1vel na mem\u00f3ria.\nCertifique-se de que tem um componente de mem\u00f3ria SOC dispon\u00edvel para a regi\u00e3o de mem\u00f3ria:\n%s...%s
ProcReadElfNotExecutable = O arquivo de elfo n\u00e3o \u00e9 um execut\u00e1vel
ProcReadElfSuccess = Sucesso
#
# gui/AssemblerPanel.java
#
AsmPanAmsFileExtention = Arquivos de montagem (.asm,.S)
AsmPanAssemble = Montar o c\u00f3digo (ALT-A)
AsmPanDocumentChangedSave = H\u00e1 altera\u00e7\u00f5es no seu documento, guarde-as?
AsmPanErrorCreateFile = N\u00e3o \u00e9 poss\u00edvel criar o arquivo de montagem.
AsmPanErrorReadingFile = N\u00e3o \u00e9 poss\u00edvel ler o arquivo
AsmPanNextError = Saltar para o pr\u00f3ximo erro (CTRL-N)
AsmPanOpenFile = Ler um ficheiro (CTRL-L)
AsmPanPreviousError = Saltar para erro anterior (CTRL-P)
AsmPanReadAsmFile = Selecione um arquivo para ler
AsmPanRun = Executar o c\u00f3digo (ALT-R)
AsmPanSaveAsmFile = Selecione um arquivo para salvar
AsmPanSaveFile = Gravar file (CTRL-S)
AsmPanSaveFileAs = Salvar arquivo como
AsmPanSaveFirstBeforeOpen = H\u00e1 modifica\u00e7\u00f5es no documento\nVoc\u00ea quer salv\u00e1-los antes de abrir um novo arquivo?
AssemblerAssembleSuccess = Sucesso!\nN\u00e3o foram encontrados erros no seu c\u00f3digo.
AssemblerRunSuccess = O programa foi carregado com sucesso na mem\u00f3ria.\nPara executar o programa, por favor, certifique-se disso:\na) voc\u00ea habilita os ticks\nb) voc\u00ea configura o cpu para o modo de execu\u00e7\u00e3o
AssemblerUnableToDownload = N\u00e3o \u00e9 poss\u00edvel armazenar o programa na mem\u00f3ria,\npor favor, certifique-se de que tem mem\u00f3ria suficiente dispon\u00edvel\nnos locais de mem\u00f3ria correctos.
#
# gui/BreakpointPanel.java
#
RV32imAsmLineIndicator = Linha %d de %d
RV32imRemoveBreakPoint = Remover ponto de parada
RV32imSetBreakpoint = Adicionar ponto de parada
#
# gui/BusTransactionInsertionGui.java
#
SocTransInsAddress = Endere\u00e7o do autocarro: 0x
SocTransInsAtomicRequest = Transa\u00e7\u00e3o at\u00f4mica
SocTransInsByteAccess = Transa\u00e7\u00e3o de byte
SocTransInsHalfWordAccess = Transa\u00e7\u00e3o de meia palavra (2 bytes)
SocTransInsInputData = Dados para escrever: 0x
SocTransInsInsertTransaction = Inserir a transa\u00e7\u00e3o no \u00f4nibus
SocTransInsManual = Manual inserido
SocTransInsReadData = Dados devolvidos:
SocTransInsReadRequest = Pedido de leitura de barramento
SocTransInsTransResultTitle = Resultado da transa\u00e7\u00e3o inserida:
SocTransInsWordAccess = Transa\u00e7\u00e3o Word (4 bytes)
SocTransInsWriteRequest = Solicita\u00e7\u00e3o de grava\u00e7\u00e3o de barramento
#
# gui/CpuDrawSupport.java
#
Rv32imAsmInstruction = Montagem:
Rv32imBinInstruction = Opcode:
Rv32imEmptyTrace = N\u00e3o h\u00e1 vest\u00edgios de execu\u00e7\u00e3o dispon\u00edveis
Rv32imExecutionTrace = Tra\u00e7ado de execu\u00e7\u00e3o (\u00faltimo executado em cima):
Rv32imProgramCounter = pc:
Rv32imRegisterFile = Ficheiro de registo:
#
# gui/SocCPUShape.java
#
RV32ShapeSimControl = Controle de simula\u00e7\u00e3o
#
# jtaguart/JtagUart.java
#
JtagUartClearKeyb = Limpar teclado
JtagUartKeybAvailable = Dados do teclado dispon\u00edveis
JtagUartKeybData = Dados do teclado
JtagUartKeybReadEnable = Habilita\u00e7\u00e3o de leitura do teclado
JtagUartTtyClear = TTY transparente
JtagUartTtyData = Dados TTY
JtagUartTtyWrite = TTY escrever dados
Rv32imClockInput = Entrada do rel\u00f3gio
Rv32imResetInput = Entrada de reinicializa\u00e7\u00e3o
SocJtagUartComponent = Componente Jtag Uart
SocPioIrqOutput = Sa\u00edda Irq
#
# jtaguart/JtagUartAttributes.java
#
JtagSize1024 = 1k
JtagSize128 = 128
JtagSize16 = 16
JtagSize16384 = 16k
JtagSize2048 = 2k
JtagSize256 = 256
JtagSize32 = 32
JtagSize32768 = 32k
JtagSize4096 = 4k
JtagSize512 = 512
JtagSize64 = 64
JtagSize8 = 8
JtagSize8192 = 8k
JtagUartReadIrqThreshold = Ler limiar IRQ
JtagUartWriteIrqThreshold = Escrever o limiar IRQ
UartJtagREADFifoSize = Ler tamanho FIFO:
UartJtagWriteFifoSize = Escrever tamanho FIFO:
VgaStartAddress = Endere\u00e7o base:
#
# memory/SocMemory.java
#
SocMemBase = Base:
SocMemSizeStr = Tamanho:
#
# memory/SocMemoryAttributes.java
#
SocMemSize = Largura do endere\u00e7o de byte:
SocMemStartAddress = Endere\u00e7o inicial:
#
# nios2/Nios2.java
#
Nios2A = A
Nios2B = B
Nios2C = C
Nios2Component = Simulador Nios2s
Nios2Dataa = Dados A
Nios2Datab = Dados B
Nios2Done = Feito em
Nios2N = N
Nios2ReadRa = Leia Ra
Nios2ReadRb = Ler Rb
Nios2Result = Resultado
Nios2Start = In\u00edcio
Nios2WriteRc = Escrever Rc
#
# nios2/Nios2Attributes.java
#
nios2BreakVector = Vetor de Quebra
#
# nios2/Nios2CustomInstructions.java
#
AssemblerExpectedFourArguments = Quatro argumentos esperados
Nios2DonePinError = O pino executado n\u00e3o definido ou em estado de erro n\u00e3o pode continuar.\n Por favor, verifique o pino feito.
#
# nios2/Nios2OtherControlInstructions.java
#
AssemblerExpectedZeroOrOneArgument = N\u00e3o se esperava nenhum ou um argumento
Nios2AssemblerExpectedBracketedRegister = Espera-se um registro entre par\u00eanteses, por exemplo (r1)
Nios2AssemblerExpectedImmediateIndexedRegister = Espera-se um registo indexado imediato, por exemplo, 5(r1)
Nios2CannotUseControlRegister = N\u00e3o \u00e9 poss\u00edvel usar um registro de controle neste contexto
Nios2CannotUseCustomRegister = N\u00e3o \u00e9 poss\u00edvel usar um registro personalizado neste contexto
Nios2ExpectedControlRegister = Espera-se um registo de controlo (por exemplo, ctl4)
#
# nios2/Nios2ProgramControlInstructions.java
#
AssemblerExpextedImmediateOrLabel = Espera-se um valor imediato ou um r\u00f3tulo
#
# nios2/Nios2State.java
#
Nios2Bstatus = bstatus
Nios2Estatus = estatus
Nios2Status = status
#
# pio/PioAttributes.java
#
SicPioIrqType = Tipo Irq:
SocPioAnyEdge = Qualquer borda
SocPioBidir = Portas bidirecionais (tristate)
SocPioCaptureEdge = Tipo de captura:
SocPioDirection = Dire\u00e7\u00e3o:
SocPioFallingEdge = Borda de queda
SocPioGenIRQ = IRQ activado:
SocPioInout = Portas de entrada e sa\u00edda
SocPioInputCaptureBit = Captura de bit-clearing:
SocPioInputOnly = Apenas portas de entrada
SocPioInputsSyncCapture = Sincroniza\u00e7\u00e3o. Captura:
SocPioIrQEdge = Borda
SocPioIrqLevel = N\u00edvel
SocPioOutputIndividualBits = Sa\u00edda bit set/clear:
SocPioOutputOnly = Apenas portas de sa\u00edda
SocPioOutputResetValue = Valor de reposi\u00e7\u00e3o de sa\u00edda:
SocPioRisingEdge = Borda ascendente
#
# pio/PioMenu.java
#
PioMenuBidirFunctionsRemark = /* Com as seguintes fun\u00e7\u00f5es o registo bidireccional pode ser definido ou lido\n * a 1 indica que o respeito. bit \u00e9 uma sa\u00edda, um 0 indica que \u00e9 uma entrada\n * Nota: apenas os bits de %s mais baixos s\u00e3o usados.\n */
PioMenuCaptureAll = limpar todos os bits do registo de captura independentemente do valor do par\u00e2metro "valor".
PioMenuCaptureAny = pelo menos uma altera\u00e7\u00e3o de 0 para 1 ou de 1 para 0
PioMenuCaptureBit = limpar os bits no registro de captura que s\u00e3o 1 no par\u00e2metro "valor".
PioMenuCaptureFalling = pelo menos uma altera\u00e7\u00e3o de 1 para 0
PioMenuCaptureRising = pelo menos uma altera\u00e7\u00e3o de 0 para 1
PioMenuEdgeCaptureRemark = /* Com as seguintes fun\u00e7\u00f5es, o registro de captura de borda pode ser apagado ou lido\n * no caso do registro de borda ser lido um 1 em uma posi\u00e7\u00e3o indica que o\n * A respectiva entrada tem o chap\u00e9u %s,\n * caso contr\u00e1rio, a respectiva entrada n\u00e3o foi alterada.\n *\n * Escrever para este registro ser\u00e1 %s.\n * Nota: apenas os bits de %s mais baixos s\u00e3o usados.\n */
PioMenuInputDataFunctionRemark = /* Com a seguinte fun\u00e7\u00e3o, os valores de entrada do PIO podem ser\n * ? read out.\n * Esta fun\u00e7\u00e3o retorna o respectivo valor\n * Nota: apenas os bits %s mais baixos s\u00e3o v\u00e1lidos\n */
PioMenuIrqEdge = bit correspondente no registro de captura
PioMenuIrqLevel = entrada correspondente
PioMenuMaskFunctionsRemark = /* Com as seguintes fun\u00e7\u00f5es, o registro da m\u00e1scara de interrup\u00e7\u00e3o pode ser configurado ou lido.\n * A 1 em uma localiza\u00e7\u00e3o espec\u00edfica indica que uma interrup\u00e7\u00e3o ser\u00e1 gerada\n * se a %s for igual a 1.\n * Nota: apenas os bits de %s mais baixos s\u00e3o usados.\n */
PioMenuOutClearRemark = /* Com a seguinte fun\u00e7\u00e3o os bits que s\u00e3o 1 no par\u00e2metro "valor" for\u00e7ar\u00e3o\n * a sa\u00edda correspondente a 0\n * Nota: apenas os bits de %s mais baixos s\u00e3o usados.\n */
PioMenuOutputDataFunctionRemark = /* Com a seguinte fun\u00e7\u00e3o, os valores de sa\u00edda do PIO podem ser\n * set.\n * Esta fun\u00e7\u00e3o toma o novo valor de sa\u00edda como par\u00e2metro "valor".\n * Nota: apenas os bits %s mais baixos do par\u00e2metro "valor" fornecido s\u00e3o v\u00e1lidos.\n */
PioMenuOutSetRemark = /* Com a seguinte fun\u00e7\u00e3o os bits que s\u00e3o 1 no par\u00e2metro "valor" for\u00e7ar\u00e3o\n * a sa\u00edda correspondente a 1\n * Nota: apenas os bits de %s mais baixos s\u00e3o usados.\n */
#
# pio/SocPio.java
#
SocPioBidirPinx = Bidir bit %s
SocPioBidirs = Pinos bidirecionais
SocPioComponent = Expansor de entrada/sa\u00edda paralela
SocPioInputPinx = Bit de entrada %s
SocPioInputs = Pinos de entrada
SocPioOutputPinx = Bit de sa\u00edda %s
SocPioOutputs = Pinos de sa\u00edda
SocPioResetInput = Entrada de reinicializa\u00e7\u00e3o
#
# rv32im/RV32im_M_ExtensionInstructions.java
#
AssemblerExpectedRegister = Esperava um registo
AssemblerExpectedThreeArguments = Tr\u00eas argumentos esperados
AssemblerUnknownRegister = Registro desconhecido
#
# rv32im/Rv32im_riscv.java
#
Rv32imComponent = Simulador Risc V IM
Rv32imIrqInput = Entrada IRQ %s
#
# rv32im/RV32im_state.java
#
RV32imBreakPointReached = A execu\u00e7\u00e3o \u00e9 pausada devido a um ponto de parada definido na instru\u00e7\u00e3o atual.
RV32imFetchExecutionError = Erro na execu\u00e7\u00e3o da instru\u00e7\u00e3o buscada
RV32imFetchInvalidInstruction = Instru\u00e7\u00e3o inv\u00e1lida obtida
RV32imFetchInvInstrAsm = Instru\u00e7\u00e3o inv\u00e1lida!
RV32imFetchTransaction = -> Buscar erro de transa\u00e7\u00e3o.
SocHiddenForFasterSimulation = Conte\u00fados ocultos para uma simula\u00e7\u00e3o mais r\u00e1pida
#
# rv32im/RV32imAttributes.java
#
rv32ExceptionVector = Vetor de exce\u00e7\u00e3o
rv32imIrqWidth = N\u00famero de linhas IRQ
rv32ResetVector = Repor vector
rv32StateVisable = Estado vis\u00edvel:
#
# rv32im/RV32imControlTransferInstructions.java
#
AssemblerExpectedNoArguments = N\u00e3o se esperam argumentos
AssemblerExpectedOneArgument = Um argumento esperado
Rv32imAssemblerExpectedOneOrTwoArguments = Espera-se um ou dois argumentos
Rv32imAssemblerExpectedTwoOrThreeArguments = Dois ou tr\u00eas argumentos esperados
#
# rv32im/RV32imEnvironmentCallAndBreakpoints.java
#
Rv32imECABNotImplmented = Atualmente, a chamada ambiental e os breakpoints n\u00e3o est\u00e3o implementados
#
# rv32im/RV32imIntegerRegisterImmediateInstructions.java
#
RV32imAssemblerBUG = BUG!
#
# rv32im/RV32imLoadAndStoreInstructions.java
#
AssemblerExpectedImmediateValue = Valor esperado imediato
AssemblerExpectedTwoArguments = Dois argumentos esperados
AssemblerImmediateOutOfRange = O valor imediato est\u00e1 fora do intervalo
LoadStoreErrorInReadTransaction = Erro ao executar uma carga do sistema de mem\u00f3ria:
LoadStoreErrorInWriteTransaction = Erro ao realizar um armazenamento no sistema de mem\u00f3ria:
RV32imAssemblerExpectedBracketedRegister = Espera-se um registro entre par\u00eanteses, por exemplo (x1)
RV32imAssemblerExpectedImmediateIndexedRegister = Espera-se um registo indexado imediato, por exemplo, 5(x1)
#
# rv32im/Rv32imMemoryOrderingInstructions.java
#
RV32imAssemblerNotSupportedYet = Opcode n\u00e3o suportado asm opcode
Rv32imMOINotImplmented = Atualmente as instru\u00e7\u00f5es de pedido de mem\u00f3ria n\u00e3o est\u00e3o implementadas
#
# Soc.java
#
socLibrary = Componentes do Sistema On Chip
SocMemoryComponent = Simulador de mem\u00f3ria
#
# util/AbstractAssembler.java
#
AssemblerUnknownOpcode = Desconhecido opcode
UnknownInstruction = Instru\u00e7\u00e3o desconhecida
#
# util/Assembler.java
#
AssemblerAssumingEntryPoint = Assumindo o endere\u00e7o mais baixo com uma instru\u00e7\u00e3o como ponto de entrada.\nPara se certificar de que a sua cpu come\u00e7a a ser executada no endere\u00e7o certo\npor favor adicione um r\u00f3tulo chamado '_start' no local\nonde a sua CPU deve come\u00e7ar a executar o programa.
AssemblerCannotUseInsideMacro = Esta constru\u00e7\u00e3o n\u00e3o pode ser usada dentro de uma defini\u00e7\u00e3o de macro
AssemblerEndOfMacroNotFound = N\u00e3o foi poss\u00edvel encontrar o fim da defini\u00e7\u00e3o macro
AssemblerExpectedMacroName = Espera-se um nome para a macro
AssemblerExpectedMacroNrOfParameters = N\u00famero esperado de par\u00e2metros de macro
AssemblerExpectingLabelIdentifier = Esperando um r\u00f3tulo
AssemblerMissingLabelBefore = Para este operador deve ser um r\u00f3tulo
AssemblerNoExecutableSection = N\u00e3o foram encontradas instru\u00e7\u00f5es que possam ser executadas.
AssemblerReguiresNumberAfterMath = Ap\u00f3s uma opera\u00e7\u00e3o matem\u00e1tica deve seguir um n\u00famero
AssemblerUnknowCharacter = Car\u00e1cter desconhecido
AssemblerWrongClosingBracket = Este suporte de fechamento n\u00e3o \u00e9 suportado
AssemblerWrongOpeningBracket = Este suporte de abertura n\u00e3o \u00e9 suportado
#
# util/AssemblerAsmInstruction.java
#
AssemblerCouldNotFindAddressForLabel = N\u00e3o foi poss\u00edvel determinar um endere\u00e7o para esta etiqueta
AssemblerCouldNotFindValueForDefine = N\u00e3o foi poss\u00edvel encontrar uma defini\u00e7\u00e3o deste par\u00e2metro
AssemblerDivZero = Dividir por erro zero
AssemblerExpectedImmediateValueAfterMath = Valor esperado imediato ap\u00f3s uma opera\u00e7\u00e3o matem\u00e1tica
#
# util/AssemblerInfo.java
#
AssemblerDuplicatedLabelNotSupported = Os nomes dos r\u00f3tulos devem ser \u00fanicos, encontrados v\u00e1rias defini\u00e7\u00f5es deste r\u00f3tulo
AssemblerDuplicatedName = N\u00e3o \u00e9 poss\u00edvel usar o mesmo nome para um .equ e uma etiqueta
AssemblerDuplicatedSectionError = Os nomes das sec\u00e7\u00f5es devem ser \u00fanicos, encontrados em m\u00faltiplas sec\u00e7\u00f5es com este nome
AssemblerExpectedLabel = Esperava uma etiqueta
AssemblerExpectedLabelAndNumber = Espera-se um r\u00f3tulo seguido de um valor imediato
AssemblerExpectedParameter = Um par\u00e2metro esperado nesta posi\u00e7\u00e3o
AssemblerExpectingNumber = Um n\u00famero esperado
AssemblerExpectingPositiveNumber = Esperava um n\u00famero positivo
AssemblerExpectingSectionName = Esperando um nome para esta se\u00e7\u00e3o
AssemblerExpectingString = Esperava uma string
AssemblerMacroIncorrectNumberOfParameters = N\u00famero incorreto de par\u00e2metros de macro especificados
AssemblerOverlappingSections = Esta se\u00e7\u00e3o se sobrep\u00f5e a outra se\u00e7\u00e3o
AssemblerUnknownIdentifier = N\u00e3o conhe\u00e7o este identificador
AssemblerUnsupportedAssemblerInstruction = Esta instru\u00e7\u00e3o de assembler n\u00e3o \u00e9 conhecida
AssemblerValueOutOfRange = Valor fora do intervalo
#
# util/AssemblerMacro.java
#
AssemblerMacroCallingEachotherDeadlock = As macros est\u00e3o a chamar-se umas \u00e0s outras, causando uma situa\u00e7\u00e3o de impasse.
AssemblerMacroCannotUseRecurency = A macro est\u00e1 a chamar-se a si pr\u00f3pria, causando uma situa\u00e7\u00e3o de impasse.
AssemblerMacroParameterNotDefined = Este par\u00e2metro de macro n\u00e3o est\u00e1 definido, verificar o n\u00famero de par\u00e2metros na defini\u00e7\u00e3o de macro
AssemblerUnknownLabel = Esta etiqueta n\u00e3o foi definida, por isso n\u00e3o posso us\u00e1-la.
#
# vga/SocVga.java
#
SocVgaComponent = Tela VGA
#
# vga/VgaAttributes.java
#
VgaBufferAddress = Endere\u00e7o do buffer de pixels:
VgaInitialDisplayMode = Modo inicial:
VgaMode1024x768 = 1024x768
VgaMode160x120 = 160x120
VgaMode320x240 = 320x240
VgaMode640x480 = 640x480
VgaMode800x600 = 800x600
VgaSoft1024x768 = Software 1024x768:
VgaSoft160x120 = Software 160x120:
VgaSoft320x240 = Software 320x240:
VgaSoft640x480 = Software 640x480:
VgaSoft800x600 = Software 800x600:
#
# vga/VgaMenu.java
#
ErrorCreatingHeaderAndOrCFile = N\u00e3o foi poss\u00edvel criar um ficheiro header e/ou c!
ExportC = Exportar modelos C
SelectDirectoryToStoreC = Definir diret\u00f3rio para armazenar os modelos C
SuccesCreatingHeaderAndCFile = Criou os arquivos com sucesso:\n%s\ne\n%s
VgaMenuModeSelectFunctions = /* Com as seguintes fun\u00e7\u00f5es o modo vga pode ser manipulado.\n * Ler o modo vga retorna os modos suportados (ver acima define os modos poss\u00edveis)\n * Escrever um modo suportado mudar\u00e1 o modo de exibi\u00e7\u00e3o do visor VGA\n */


