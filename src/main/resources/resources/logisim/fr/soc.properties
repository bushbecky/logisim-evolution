#
# bus/SocBus.java
#
SocBusComponent = Simulateur de bus SOC
#
# bus/SocBusAttributes.java
#
SocBusTraceSize = Taille des traces :
SocBusTraceVisable = Traces visibles :
#
# bus/SocBusMenuProvider.java
#
insertTrans = Ins\u00e9rer une transaction de bus
SocBusMemMap = Afficher la carte m\u00e9moire
SocBusTraceWindow = Afficher la trace de la ou des transaction(s) de bus
SocInsertTransWindowTitle = Ins\u00e9rer une transaction dans le bus :
TraceWindowTitleDoubleClickOnTraceToRemoveTrace = Fen\u00eatre de tra\u00e7age du bus (double-cliquez sur un trac\u00e9 pour le supprimer)
#
# data/SocBusInfo.java
#
SocBusNotConnected = Non connect\u00e9 \u00e0 un bus
#
# data/SocBusStateInfo.java
#
SocBusNoTrace = Aucune trace pr\u00e9sente
SocMemMapWindowTitle = Carte m\u00e9moire pour bus :
SocMemoryMapOk = Fermer
SocMemoryMapTitle = Carte m\u00e9moire (le rouge indique les zones de m\u00e9moire qui se chevauchent) :
#
# data/SocBusTransaction.java
#
SocBusStateMaster = Initiateur :
SocBusStateNoDataMax10chars = pas de donn\u00e9es
SocBusStateSlave = R\u00e9pondeur :
SocBusStateTraceIndex = N\u00b0 de transaction.. :
SocTransactionByteAccesNoSupport = L'esclave ne prend pas en charge les acc\u00e8s par octets.
SocTransactionByteAccesNoSupportShort = Pas d'acc\u00e8s aux octets
SocTransactionHalfWordAccesNoSupport = L'esclave ne prend pas en charge les acc\u00e8s en demi-mot.
SocTransactionHalfWordAccesNoSupportShort = Pas d'acc\u00e8s HW
SocTransactionMisallignedAddress = L'esclave a d\u00e9tect\u00e9 une adresse mal align\u00e9e.
SocTransactionMisallignedAddressShort = Misal. Adr.
SocTransactionMultipleSlaveAnswers = Plusieurs esclaves ont r\u00e9pondu \u00e0 une transaction. Veuillez v\u00e9rifier la carte m\u00e9moire de vos esclaves.
SocTransactionMultipleSlaveAnswersShort = Esclaves multiples
SocTransactionNoBusConnected = Le composant ma\u00eetre n'est connect\u00e9 \u00e0 aucun Soc Bus. Veuillez raccorder le ma\u00eetre \u00e0 un composant bus.
SocTransactionNoBusConnectedShort = Pas de bus
SocTransactionNoneAtomicRW = Une action de lecture/\u00e9criture non atomique est demand\u00e9e. Ceci n'est pas permis.
SocTransactionNoneAtomicRWShort = Aucun RW atomique
SocTransactionNoRespons = Aucun composant esclave n'a r\u00e9pondu \u00e0 la demande. Veuillez v\u00e9rifier l'adresse m\u00e9moire de la demande et la carte m\u00e9moire de votre syst\u00e8me.
SocTransactionNoResponsShort = Pas de r\u00e9ponse
SocTransactionNoSlavesAttached = Le bus qui est connect\u00e9 au ma\u00eetre n'a pas d'esclaves connect\u00e9s. Veuillez attacher des esclaves au bus.
SocTransactionNoSlavesAttachedShort = Pas d'esclaves
SocTransactionReadOnlyAccessError = L'esclave ne supporte que les acc\u00e8s en lecture sur cette adresse
SocTransactionReadOnlyAccessErrorShort = Lecture seule
SocTransactionRegisterDoesNotExist = L'esclave ne supporte aucun acc\u00e8s sur cette adresse
SocTransactionRegisterDoesNotExistShort = Pas d'acc\u00e8s
SocTransactionSuccessfull = Aucune erreur n'est survenue, la transaction est r\u00e9ussie.
SocTransactionSuccessfullShort = Succ\u00e8s
SocTransactionUnknownError = Bizarre, ce message d'erreur ne devrait jamais se produire et repr\u00e9sente un bug dans logisim.
SocTransactionUnknownErrorShort = BUG !
SocTransactionWordAccesNoSupport = L'esclave ne prend pas en charge les acc\u00e8s par mot.
SocTransactionWordAccesNoSupportShort = Pas d'acc\u00e8s aux mots
SocTransactionWriteOnlyAccessError = L'esclave ne prend pas en charge une action de lecture sur cette adresse.
SocTransactionWriteOnlyAccessErrorShort = \u00c9crire seulement
#
# data/SocMemMapModel.java
#
SocMemMapEmpty = Vide (pas d'esclaves)
SocMemMapEndAddress = Adresse de fin :
SocMemMapSlaveName = Nom du composant :
SocMemMapStartAddress = Adresse de d\u00e9part :
#
# data/SocSimulationManager.java
#
SocBusManagerSelectBus = Veuillez s\u00e9lectionner un bus pour vous connecter \u00e0
SocBusSelectAttr = Bus connect\u00e9
SocBusSelectAttrClick = Cliquez pour s\u00e9lectionner
SocManagerNoBusses = Pas de bus disponible, veuillez ajouter un bus SOC \u00e0 votre sch\u00e9ma.
#
# data/SocUpMenuProvider.java
#
ProcReadElfLoadedAndEntrySet = A charg\u00e9 avec succ\u00e8s le fichier elf dans la m\u00e9moire.\nLe point d'entr\u00e9e de l'ex\u00e9cutable a \u00e9t\u00e9 d\u00e9fini sur le processeur.\n\nImportant :\n   Comme le fichier elf ne contient aucune information sur les vecteurs d'exception\n   tu dois les contr\u00f4ler toi-m\u00eame !
SocUpMenuAsmWindow = Assembleur ouvert
SocUpMenuCpuAsmWindowTitle = assembleur pour processeur cpu :
SocUpMenuCpuProgramWindowTitle = d\u00e9sassembleur pour processeur cpu :
SocUpMenuCpuStateWindowTitle = \u00e9tat du processeur pour cpu :
SocUpMenuErrorReadingElfTitle = Erreur dans la lecture du fichier elf
SocUpMenuReadElf = Lire le fichier elf
SocUpMenuSelectElfFile = S\u00e9lectionner le fichier elf \u00e0 importer
SocUpMenuShowProgram = Afficher le programme charg\u00e9
SocUpMenuShowState = Afficher l'\u00e9tat du CPU
#
# data/SocUpSimulationState.java
#
SocUpSimHalt = Arr\u00eat\u00e9
SocUpSimHaltBreak = Point de rupture
SocUpSimHaltError = Erreur
SocUpSimRunning = Course \u00e0 pied
SocUpSimStateLabel = Etat Sim :
SocUpSimstateStart = D\u00e9but
SocUpSimstateStop = Pause
SocUpUnknown = Inconnu
#
# file/ElfHeader.java
#
ElfHeaderEIClassError = Pas un fichier elf 32 ou 64 bits
ElfHeaderEIDataError = Pas un petit ou un gros fichier encod\u00e9 en endian
ElfHeaderIncorrectEISize = La taille de la section EI est incorrecte
ElfHeaderIncorrectESize = La taille de la section E est incorrecte.
ElfHeaderIncorrectMagic = Le fichier ne contient pas le bon elf-magic ; probablement pas un elf-fichier.
ElfHeaderNoErrors = L'en-t\u00eate est correct
ElfHeaderReadingFileError = Erreur de lecture du fichier
ElfHeaderUnknownArchitecture = Architecture inconnue
#
# file/ElfProgramHeader.java
#
ProgHeaderNotFound = En-t\u00eate de programme introuvable.
ProgHeaderReadError = Erreur de lecture de l'en-t\u00eate du programme.
ProgHeaderSizeError = Incoh\u00e9rence de taille dans l'en-t\u00eate du programme.
ProgHeaderSuccess = Succ\u00e8s
#
# file/ElfSectionHeader.java
#
ElfSectHeadMultiStringtabError = J'ai trouv\u00e9 plusieurs tables de cha\u00eenes de caract\u00e8res, non prises en charge pour le moment.
ElfSectHeadMultiSymtabError = J'ai trouv\u00e9 plusieurs tables de symboles, non prises en charge pour le moment ;
ElfSectHeadNotFound = En-t\u00eate de section introuvable.
ElfSectHeadReadError = En-t\u00eate de la section de lecture des erreurs.
ElfSectHeadSizeError = Incoh\u00e9rence de taille dans l'en-t\u00eate de section.
ElfSectHeadStingIdxError = Indice de cha\u00eene d'erreurs.
ElfSectHeadStingNotFound = Le nom de la section n'a pas \u00e9t\u00e9 trouv\u00e9.
ElfSectHeadStingReadError = Erreur de lecture de la table des cha\u00eenes de caract\u00e8res.
ElfSectHeadStingTypeError = Erreur de type cha\u00eene de caract\u00e8res.
ElfSectHeadSuccess = Succ\u00e8s
ElfSymTableNotFound = Impossible de trouver le tableau des symboles.
ElfSymTableReadError = Impossible de lire le tableau des symboles.
#
# file/ProcessorReadElf.java
#
ProcReadElf64BitNotSupportedYet = Logisim ne supporte pas encore les fichiers elf 64 bits.
ProcReadElfArchError = Le fichier elfe est pour un processeur "%s" alors qu'il devrait \u00eatre pour un processeur "%s".
ProcReadElfEndianMismatch = Incoh\u00e9rence endiane, le fichier elf est "%s" alors que le processeur a demand\u00e9 "%s".
ProcReadElfErrorOpeningFile = Impossible d'ouvrir la lime \u00e0 elfes
ProcReadElfLoadableSectionNotFound = Section chargeable non trouv\u00e9e dans le fichier elf.
ProcReadElfLoadableSectionReadError = Erreur de lecture section chargeable.
ProcReadElfLoadableSectionSizeError = D\u00e9salignement des tailles dans la section chargeable.
ProcReadElfLoadableSectionTooBig = La taille de la section chargeable est plus grande que la taille support\u00e9e par logisim.
ProcReadElfMemoryError = Une erreur s'est produite lors de l'\u00e9criture d'une section chargeable en m\u00e9moire.\nAssurez-vous d'avoir un composant de m\u00e9moire SOC disponible pour la r\u00e9gion m\u00e9moire :\n%s...%s
ProcReadElfNotExecutable = Le fichier elf n'est pas un ex\u00e9cutable
ProcReadElfSuccess = Succ\u00e8s
#
# gui/AssemblerPanel.java
#
AsmPanAmsFileExtention = Fichiers d'assemblage (.asm,.S)
AsmPanAssemble = Assemblez le code (ALT-A)
AsmPanDocumentChangedSave = Il y a des changements dans votre document, sauvegardez-les ?
AsmPanErrorCreateFile = Impossible de cr\u00e9er le fichier d'assemblage.
AsmPanErrorReadingFile = Impossible de lire le fichier
AsmPanNextError = Passer \u00e0 l'erreur suivante (CTRL-N)
AsmPanOpenFile = Lire un fichier (CTRL-L)
AsmPanPreviousError = Aller \u00e0 l'erreur pr\u00e9c\u00e9dente (CTRL-P)
AsmPanReadAsmFile = S\u00e9lectionnez un fichier \u00e0 lire
AsmPanRun = Ex\u00e9cuter le code (ALT-R)
AsmPanSaveAsmFile = S\u00e9lectionnez un fichier \u00e0 enregistrer
AsmPanSaveFile = Enregistrer le fichier (CTRL-S)
AsmPanSaveFileAs = Enregistrer le fichier sous
AsmPanSaveFirstBeforeOpen = Il y a des changements dans votre document\nVoulez-vous les enregistrer avant d'ouvrir un nouveau fichier ?
AssemblerAssembleSuccess = Succ\u00e8s !\nAucune erreur trouv\u00e9e dans votre code.
AssemblerRunSuccess = A charg\u00e9 avec succ\u00e8s le programme en m\u00e9moire.\nPour ex\u00e9cuter le programme, assurez-vous que :\na) vous activez les tiques\nb) vous mettez le processeur en mode de fonctionnement
AssemblerUnableToDownload = Impossible de stocker le programme en m\u00e9moire,\nassurez-vous d'avoir suffisamment de m\u00e9moire disponible\naux bons emplacements de m\u00e9moire.
#
# gui/BreakpointPanel.java
#
RV32imAsmLineIndicator = Ligne %d de %d
RV32imRemoveBreakPoint = Supprimer le point de rupture
RV32imSetBreakpoint = Ajouter un point de rupture
#
# gui/BusTransactionInsertionGui.java
#
SocTransInsAddress = Adresse du bus : 0x
SocTransInsAtomicRequest = Transaction atomique
SocTransInsByteAccess = Octet de transaction
SocTransInsHalfWordAccess = Transaction en demi-mot (2 octets)
SocTransInsInputData = Donn\u00e9es \u00e0 \u00e9crire : 0x
SocTransInsInsertTransaction = Ins\u00e9rer la transaction dans le bus
SocTransInsManual = Insertion manuelle
SocTransInsReadData = Donn\u00e9es retourn\u00e9es :
SocTransInsReadRequest = Demande de lecture du bus
SocTransInsTransResultTitle = R\u00e9sultat de la transaction ins\u00e9r\u00e9e :
SocTransInsWordAccess = Transaction Word (4 octets)
SocTransInsWriteRequest = Demande d'\u00e9criture de bus
#
# gui/CpuDrawSupport.java
#
Rv32imAsmInstruction = Assemblage :
Rv32imBinInstruction = Opcode :
Rv32imEmptyTrace = Aucune trace d'ex\u00e9cution disponible
Rv32imExecutionTrace = Trace d'ex\u00e9cution (derni\u00e8re ex\u00e9cution en haut) :
Rv32imProgramCounter = pc :
Rv32imRegisterFile = Enregistrer fichier :
#
# gui/SocCPUShape.java
#
RV32ShapeSimControl = Contr\u00f4le de simulation
#
# memory/SocMemory.java
#
SocMemBase = Base :
SocMemSizeStr = Taille :
#
# memory/SocMemoryAttributes.java
#
SocMemSize = Largeur de l'adresse de l'octet :
SocMemStartAddress = Adresse de d\u00e9part :
#
# nios2/Nios2.java
#
Nios2A = A
Nios2B = B
Nios2C = C
Nios2Component = Simulateur Nios2s
Nios2Dataa = Donn\u00e9es A
Nios2Datab = Donn\u00e9es B
Nios2Done = Fait
Nios2N = N
Nios2ReadRa = Lisez Ra
Nios2ReadRb = Lire Rb
Nios2Result = R\u00e9sultat
Nios2Start = D\u00e9but
Nios2WriteRc = Ecrire Rc
#
# nios2/Nios2Attributes.java
#
nios2BreakVector = Vecteur de rupture
#
# nios2/Nios2CustomInstructions.java
#
AssemblerExpectedFourArguments = On s'attendait \u00e0 quatre arguments
Nios2DonePinError = Si la broche n'est pas d\u00e9finie ou si elle est dans un \u00e9tat d'erreur, il n'est pas possible de continuer.\n S'il vous pla\u00eet, v\u00e9rifiez l'\u00e9pingle faite.
#
# nios2/Nios2OtherControlInstructions.java
#
AssemblerExpectedZeroOrOneArgument = Aucun ou un seul argument n'\u00e9tait attendu
Nios2AssemblerExpectedBracketedRegister = Attendu un registre entre crochets, par exemple (r1)
Nios2AssemblerExpectedImmediateIndexedRegister = On s'attendait \u00e0 un registre index\u00e9 imm\u00e9diat, p. ex. 5(r1)
Nios2CannotUseControlRegister = Impossible d'utiliser un registre de contr\u00f4le dans ce contexte
Nios2CannotUseCustomRegister = Impossible d'utiliser un registre personnalis\u00e9 dans ce contexte
Nios2ExpectedControlRegister = Attendu un registre de contr\u00f4le (par ex. ctl4)
#
# nios2/Nios2ProgramControlInstructions.java
#
AssemblerExpextedImmediateOrLabel = Attendu une valeur imm\u00e9diate ou un label
#
# nios2/Nios2State.java
#
Nios2Bstatus = bstatus
Nios2Estatus = estatus
Nios2Status = situation
#
# pio/PioAttributes.java
#
SicPioIrqType = Type Irq :
SocPioAnyEdge = N'importe quel bord
SocPioBidir = Ports bidirectionnels (tristates)
SocPioCaptureEdge = Type de capture :
SocPioDirection = Direction :
SocPioFallingEdge = Bord de chute
SocPioGenIRQ = IRQ activ\u00e9 :
SocPioInout = Ports d'entr\u00e9e et de sortie
SocPioInputCaptureBit = Nettoyage du tr\u00e9pan de capture :
SocPioInputOnly = Ports d'entr\u00e9e uniquement
SocPioInputsSyncCapture = Synchronisation de la capture :
SocPioIrQEdge = Bord
SocPioIrqLevel = Niveau
SocPioOutputIndividualBits = Bit de sortie activ\u00e9/effac\u00e9 :
SocPioOutputOnly = Ports de sortie uniquement
SocPioOutputResetValue = Valeur de r\u00e9initialisation de la sortie :
SocPioRisingEdge = Ar\u00eate montante
#
# pio/PioMenu.java
#
PioMenuBidirFunctionsRemark = /* Les fonctions suivantes permettent de r\u00e9gler ou de lire le registre bidirectionnel\n * a 1 indique que le bit de respect est une sortie, a 0 indique qu'il est une entr\u00e9e\n * Remarque : seuls les bits %s inf\u00e9rieurs sont utilis\u00e9s.\n */
PioMenuCaptureAll = effacer tous les bits du registre de capture ind\u00e9pendamment de la valeur du param\u00e8tre "valeur".
PioMenuCaptureAny = au moins un changement de 0 \u00e0 1 ou de 1 \u00e0 0
PioMenuCaptureBit = effacer les bits du registre de capture qui sont 1 dans le param\u00e8tre "value".
PioMenuCaptureFalling = au moins un changement de 1 \u00e0 0
PioMenuCaptureRising = au moins un changement de 0 \u00e0 1
PioMenuEdgeCaptureRemark = /* Les fonctions suivantes permettent d'effacer ou de lire le registre de capture des fronts\n * dans le cas o\u00f9 le registre de bord est lu un 1 sur une position indique que l'option\n * l'entr\u00e9e respective a des %s de chapeau,\n * sinon l'entr\u00e9e correspondante n'a pas chang\u00e9.\n *\n * Ecrire dans ce registre sera %s.\n * Remarque : seuls les bits %s inf\u00e9rieurs sont utilis\u00e9s.\n */
PioMenuInputDataFunctionRemark = /* Avec la fonction suivante, les valeurs d'entr\u00e9e du PIO peuvent \u00eatre\n * read out.\n * Cette fonction renvoie la valeur correspondante\n * Remarque : seuls les bits %s inf\u00e9rieurs sont valides.\n */
PioMenuIrqEdge = bit correspondant dans le registre de capture
PioMenuIrqLevel = entr\u00e9e correspondante
PioMenuMaskFunctionsRemark = /* Les fonctions suivantes permettent de r\u00e9gler ou de lire le registre des masques d'interruption.\n * Un 1 sur un emplacement sp\u00e9cifique indique qu'une interruption sera g\u00e9n\u00e9r\u00e9e\n * si le %s est \u00e9gal \u00e0 1.\n * Remarque : seuls les bits %s inf\u00e9rieurs sont utilis\u00e9s.\n */
PioMenuOutClearRemark = /* Avec la fonction suivante, les bits qui sont 1 dans le param\u00e8tre "valeur" forceront\n * la sortie correspondante \u00e0 0\n * Remarque : seuls les bits %s inf\u00e9rieurs sont utilis\u00e9s.\n */
PioMenuOutputDataFunctionRemark = /* Avec la fonction suivante, les valeurs de sortie du PIO peuvent \u00eatre\n *Set.\n * Cette fonction prend la nouvelle valeur de sortie comme param\u00e8tre "valeur".\n * Remarque : seuls les bits %s inf\u00e9rieurs du param\u00e8tre "value" fourni sont valides.\n */
PioMenuOutSetRemark = /* Avec la fonction suivante, les bits qui sont 1 dans le param\u00e8tre "valeur" forceront\n * la sortie correspondante \u00e0 1\n * Remarque : seuls les bits %s inf\u00e9rieurs sont utilis\u00e9s.\n */
#
# pio/SocPio.java
#
SocPioBidirPinx = Bit Bidir %s
SocPioBidirs = Broches bidirectionnelles
SocPioComponent = Expandeur d'entr\u00e9e/sortie parall\u00e8le
SocPioInputPinx = Bit d'entr\u00e9e %s
SocPioInputs = Broches d'entr\u00e9e
SocPioIrqOutput = Sortie Irq
SocPioOutputPinx = Bit de sortie %s
SocPioOutputs = Broches de sortie
SocPioResetInput = Entr\u00e9e de r\u00e9initialisation
#
# rv32im/RV32im_M_ExtensionInstructions.java
#
AssemblerExpectedRegister = Attendu un registre
AssemblerExpectedThreeArguments = Attendu trois arguments
AssemblerUnknownRegister = Registre inconnu
#
# rv32im/Rv32im_riscv.java
#
Rv32imClockInput = Entr\u00e9e horloge
Rv32imComponent = Simulateur Risc V IM
Rv32imIrqInput = Entr\u00e9e IRQ %s
Rv32imResetInput = Entr\u00e9e de r\u00e9initialisation
#
# rv32im/RV32im_state.java
#
RV32imBreakPointReached = L'ex\u00e9cution est interrompue en raison d'un point d'arr\u00eat r\u00e9gl\u00e9 sur l'instruction en cours.
RV32imFetchExecutionError = Erreur dans l'ex\u00e9cution de l'instruction r\u00e9cup\u00e9r\u00e9e
RV32imFetchInvalidInstruction = L'instruction non valide a \u00e9t\u00e9 r\u00e9cup\u00e9r\u00e9e.
RV32imFetchInvInstrAsm = Instruction invalide !
RV32imFetchTransaction = -> Erreur de transaction de r\u00e9cup\u00e9ration.
SocHiddenForFasterSimulation = Contenu cach\u00e9 pour une simulation plus rapide
#
# rv32im/RV32imAttributes.java
#
rv32ExceptionVector = Vecteur d'exception
rv32imIrqWidth = Nombre de lignes IRQ
rv32ResetVector = R\u00e9initialiser le vecteur
rv32StateVisable = \u00c9tat visible :
#
# rv32im/RV32imControlTransferInstructions.java
#
AssemblerExpectedNoArguments = Pas d'arguments attendus
AssemblerExpectedOneArgument = Attendu un argument
Rv32imAssemblerExpectedOneOrTwoArguments = On s'attendait \u00e0 un ou deux arguments
Rv32imAssemblerExpectedTwoOrThreeArguments = On s'attendait \u00e0 deux ou trois arguments
#
# rv32im/RV32imEnvironmentCallAndBreakpoints.java
#
Rv32imECABNotImplmented = \u00c0 l'heure actuelle, les points d'appel et les points d'arr\u00eat environnementaux ne sont pas mis en \u0153uvre.
#
# rv32im/RV32imIntegerRegisterImmediateInstructions.java
#
RV32imAssemblerBUG = BUG !
#
# rv32im/RV32imLoadAndStoreInstructions.java
#
AssemblerExpectedImmediateValue = Une valeur attendue imm\u00e9diate
AssemblerExpectedTwoArguments = Attendu deux arguments
AssemblerImmediateOutOfRange = La valeur imm\u00e9diate est hors plage
LoadStoreErrorInReadTransaction = Erreur lors de l'ex\u00e9cution d'une charge \u00e0 partir du syst\u00e8me de m\u00e9moire :
LoadStoreErrorInWriteTransaction = Erreur lors de l'ex\u00e9cution d'une m\u00e9morisation dans le syst\u00e8me de m\u00e9moire :
RV32imAssemblerExpectedBracketedRegister = Attendu un registre entre crochets, par exemple (x1)
RV32imAssemblerExpectedImmediateIndexedRegister = On s'attendait \u00e0 un registre index\u00e9 imm\u00e9diat, p. ex. 5(x1)
#
# rv32im/Rv32imMemoryOrderingInstructions.java
#
RV32imAssemblerNotSupportedYet = Opcode asm non support\u00e9
Rv32imMOINotImplmented = Actuellement, les instructions de commande de m\u00e9moire ne sont pas impl\u00e9ment\u00e9es.
#
# Soc.java
#
socLibrary = Composants System On Chip
SocMemoryComponent = Simulateur de m\u00e9moire
#
# util/AbstractAssembler.java
#
AssemblerUnknownOpcode = Code optique inconnu
UnknownInstruction = Enseignement inconnu
#
# util/Assembler.java
#
AssemblerAssumingEntryPoint = En supposant l'adresse la plus basse avec une instruction comme point d'entr\u00e9e.\nPour vous assurer que votre processeur commence \u00e0 s'ex\u00e9cuter \u00e0 la bonne adresse\nveuillez ajouter une \u00e9tiquette appel\u00e9e'_start' \u00e0 l'emplacement\no\u00f9 votre processeur devrait commencer \u00e0 ex\u00e9cuter le programme.
AssemblerCannotUseInsideMacro = Cette construction ne peut pas \u00eatre utilis\u00e9e \u00e0 l'int\u00e9rieur d'une macro-d\u00e9finition
AssemblerEndOfMacroNotFound = Impossible de trouver la fin de la macro-d\u00e9finition
AssemblerExpectedMacroName = Attendu un nom de la macro
AssemblerExpectedMacroNrOfParameters = Nombre pr\u00e9vu de param\u00e8tres macro\u00e9conomiques
AssemblerExpectingLabelIdentifier = Attente d'une \u00e9tiquette
AssemblerMissingLabelBefore = Pour cet op\u00e9rateur doit \u00eatre une \u00e9tiquette
AssemblerNoExecutableSection = Aucune instruction ne peut \u00eatre ex\u00e9cut\u00e9e.
AssemblerReguiresNumberAfterMath = Apr\u00e8s une op\u00e9ration math\u00e9matique devrait suivre un nombre
AssemblerUnknowCharacter = Caract\u00e8re inconnu
AssemblerWrongClosingBracket = Ce support de fermeture n'est pas support\u00e9
AssemblerWrongOpeningBracket = Ce support d'ouverture n'est pas support\u00e9
#
# util/AssemblerAsmInstruction.java
#
AssemblerCouldNotFindAddressForLabel = Impossible de d\u00e9terminer une adresse pour cette \u00e9tiquette
AssemblerCouldNotFindValueForDefine = Impossible de trouver une d\u00e9finition de ce param\u00e8tre
AssemblerDivZero = Diviser par z\u00e9ro erreur
AssemblerExpectedImmediateValueAfterMath = Valeur attendue imm\u00e9diatement apr\u00e8s une op\u00e9ration math\u00e9matique
#
# util/AssemblerInfo.java
#
AssemblerDuplicatedLabelNotSupported = Les noms d'\u00e9tiquettes doivent \u00eatre uniques, plusieurs d\u00e9finitions de cette \u00e9tiquette ont \u00e9t\u00e9 trouv\u00e9es.
AssemblerDuplicatedName = Impossible d'utiliser le m\u00eame nom pour un.equ et une \u00e9tiquette
AssemblerDuplicatedSectionError = Les noms de sections doivent \u00eatre uniques, trouv\u00e9s plusieurs sections avec ce nom
AssemblerExpectedLabel = Attendu une \u00e9tiquette
AssemblerExpectedLabelAndNumber = Attendu une \u00e9tiquette suivie d'une valeur imm\u00e9diate
AssemblerExpectedParameter = Attendait un param\u00e8tre \u00e0 cette position
AssemblerExpectingNumber = On s'attendait \u00e0 un certain nombre
AssemblerExpectingPositiveNumber = On s'attendait \u00e0 un nombre positif
AssemblerExpectingSectionName = Attente d'un nom pour cette section
AssemblerExpectingString = Attendu une cha\u00eene de caract\u00e8res
AssemblerMacroIncorrectNumberOfParameters = Nombre incorrect de param\u00e8tres macro sp\u00e9cifi\u00e9s
AssemblerOverlappingSections = Cette section recoupe une autre section
AssemblerUnknownIdentifier = Je ne connais pas cet identifiant
AssemblerUnsupportedAssemblerInstruction = Cette instruction assembleur n'est pas connue
AssemblerValueOutOfRange = La valeur est hors plage
#
# util/AssemblerMacro.java
#
AssemblerMacroCallingEachotherDeadlock = Les macros s'appellent l'une l'autre, ce qui cr\u00e9e une situation d'impasse.
AssemblerMacroCannotUseRecurency = Macro s'appelle lui-m\u00eame, ce qui provoque une situation d'impasse.
AssemblerMacroParameterNotDefined = Ce param\u00e8tre macro n'est pas d\u00e9fini, v\u00e9rifiez le nombre de param\u00e8tres dans votre d\u00e9finition de macro.
AssemblerUnknownLabel = Cette \u00e9tiquette n'a pas \u00e9t\u00e9 d\u00e9finie, donc je ne peux pas l'utiliser
#
# vga/SocVga.java
#
SocVgaComponent = \u00e9cran VGA
#
# vga/VgaAttributes.java
#
VgaBufferAddress = Adresse du tampon de pixels :
VgaInitialDisplayMode = Mode initial :
VgaMode1024x768 = 1024x768
VgaMode160x120 = 160x120
VgaMode320x240 = 320x240
VgaMode640x480 = 640x480
VgaMode800x600 = 800x600
VgaSoft1024x768 = Logiciel 1024x768 :
VgaSoft160x120 = Logiciel 160x120 :
VgaSoft320x240 = Logiciel 320x240 :
VgaSoft640x480 = Logiciel 640x480 :
VgaSoft800x600 = Logiciel 800x600 :
VgaStartAddress = Adresse de base :
#
# vga/VgaMenu.java
#
ErrorCreatingHeaderAndOrCFile = Impossible de cr\u00e9er un en-t\u00eate et/ou un fichier c !
ExportC = Exporter des mod\u00e8les C
SelectDirectoryToStoreC = D\u00e9finir le r\u00e9pertoire pour stocker les C-templates
SuccesCreatingHeaderAndCFile = A cr\u00e9\u00e9 avec succ\u00e8s les fichiers :\n%s\net\n%s
VgaMenuModeSelectFunctions = /* Avec les fonctions suivantes, le mode vga peut \u00eatre manipul\u00e9.\n * La lecture du mode vga renvoie les modes support\u00e9s (voir ci-dessus les d\u00e9finitions des modes possibles).\n * L'\u00e9criture d'un mode support\u00e9 changera le mode d'affichage de l'affichage VGA.\n */


