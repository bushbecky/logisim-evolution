#
# bus/SocBus.java
#
SocBusComponent = Simulador de bus SOC
#
# bus/SocBusAttributes.java
#
SocBusTraceSize = Tama\u00f1o del rastro:
SocBusTraceVisable = Rastros visibles:
#
# bus/SocBusMenuProvider.java
#
insertTrans = Insertar una transacci\u00f3n de bus
SocBusMemMap = Mostrar mapa de memoria
SocBusTraceWindow = Mostrar el rastreo de transacci\u00f3n(es) de bus
SocInsertTransWindowTitle = Insertar una transacci\u00f3n en el bus:
TraceWindowTitleDoubleClickOnTraceToRemoveTrace = Ventana de rastreo de bus (haga doble clic en un rastreo para eliminarlo)
#
# data/SocBusInfo.java
#
SocBusNotConnected = No conectado a un bus
#
# data/SocBusStateInfo.java
#
SocBusNoTrace = No hay rastros presentes
SocMemMapWindowTitle = Mapa de memoria para el bus:
SocMemoryMapOk = Cerrar
SocMemoryMapTitle = Mapa de memoria (el rojo indica regiones de memoria superpuestas):
#
# data/SocBusTransaction.java
#
SocBusStateMaster = Iniciador:
SocBusStateNoDataMax10chars = ning\u00fan dato
SocBusStateSlave = Respondedor:
SocBusStateTraceIndex = N\u00famero de operaci\u00f3n..:
SocTransactionByteAccesNoSupport = Slave no soporta accesos byte.
SocTransactionByteAccesNoSupportShort = Sin acceso a bytes
SocTransactionHalfWordAccesNoSupport = Slave no soporta accesos de media palabra.
SocTransactionHalfWordAccesNoSupportShort = Sin acceso a HW
SocTransactionMisallignedAddress = El esclavo detect\u00f3 una direcci\u00f3n desalineada.
SocTransactionMisallignedAddressShort = Misal. Addr.
SocTransactionMultipleSlaveAnswers = Varios esclavos respondieron a una transacci\u00f3n. Compruebe el mapa de memoria de sus esclavos.
SocTransactionMultipleSlaveAnswersShort = M\u00faltiples esclavos
SocTransactionNoBusConnected = El componente maestro no est\u00e1 conectado a ning\u00fan bus Soc. Conecte el m\u00e1ster a un componente de bus.
SocTransactionNoBusConnectedShort = No hay autob\u00fas
SocTransactionNoneAtomicRW = Se solicita una acci\u00f3n de lectura/escritura no at\u00f3mica. Esto no est\u00e1 permitido.
SocTransactionNoneAtomicRWShort = Ninguno at\u00f3mico RW
SocTransactionNoRespons = Ning\u00fan componente esclavo respondi\u00f3 a la petici\u00f3n. Compruebe la direcci\u00f3n de memoria de la solicitud y el mapa de memoria de su sistema.
SocTransactionNoResponsShort = No hay respuesta
SocTransactionNoSlavesAttached = El bus que est\u00e1 conectado al maestro no tiene esclavos conectados. Por favor, conecte algunos esclavos al autob\u00fas.
SocTransactionNoSlavesAttachedShort = No hay esclavos
SocTransactionReadOnlyAccessError = Slave soporta s\u00f3lo accesos de lectura en esta direcci\u00f3n
SocTransactionReadOnlyAccessErrorShort = S\u00f3lo lectura
SocTransactionRegisterDoesNotExist = Slave no soporta ning\u00fan acceso en esta direcci\u00f3n
SocTransactionRegisterDoesNotExistShort = Sin acceso
SocTransactionSuccessfull = No se ha producido ning\u00fan error, la operaci\u00f3n es correcta.
SocTransactionSuccessfullShort = \u00c9xito
SocTransactionUnknownError = Bizarre, este mensaje de error nunca deber\u00eda ocurrir y representa un error en logisim.
SocTransactionUnknownErrorShort = \u00a1BUG!
SocTransactionWordAccesNoSupport = El esclavo no soporta accesos de palabra.
SocTransactionWordAccesNoSupportShort = No hay acceso de palabras
SocTransactionWriteOnlyAccessError = Slave no soporta una acci\u00f3n de lectura en esta direcci\u00f3n.
SocTransactionWriteOnlyAccessErrorShort = Escribir s\u00f3lo
#
# data/SocMemMapModel.java
#
SocMemMapEmpty = Vac\u00edo (sin esclavos)
SocMemMapEndAddress = Direcci\u00f3n de destino:
SocMemMapSlaveName = Nombre del componente:
SocMemMapStartAddress = Direcci\u00f3n de inicio:
#
# data/SocSimulationManager.java
#
SocBusManagerSelectBus = Por favor, seleccione el autob\u00fas al que desea conectarse
SocBusSelectAttr = Autob\u00fas conectado
SocBusSelectAttrClick = Haga clic para seleccionar
SocManagerNoBusses = No hay autobuses disponibles, por favor a\u00f1ada un SOC-bus a su esquema.
#
# data/SocUpMenuProvider.java
#
ProcReadElfLoadedAndEntrySet = Ha cargado con \u00e9xito el archivo elf en la memoria.\nEl punto de entrada del ejecutable se ha establecido en el procesador.\n\nImportante:\n   Como el archivo elf no tiene informaci\u00f3n sobre los vectores de excepci\u00f3n\n   tienes que controlarlos t\u00fa mismo!
SocUpMenuAsmWindow = Ensamblador abierto
SocUpMenuCpuAsmWindowTitle = ensamblador para cpu :
SocUpMenuCpuProgramWindowTitle = desensamblador para cpu :
SocUpMenuCpuStateWindowTitle = estado del procesador para cpu :
SocUpMenuErrorReadingElfTitle = Error en la lectura del archivo de elfos
SocUpMenuReadElf = Leer el archivo de elfos
SocUpMenuSelectElfFile = Seleccione el archivo elf para importar
SocUpMenuShowProgram = Mostrar programa cargado
SocUpMenuShowState = Mostrar el estado de la CPU
#
# data/SocUpSimulationState.java
#
SocUpSimHalt = Detenido
SocUpSimHaltBreak = Punto de ruptura
SocUpSimHaltError = Error
SocUpSimRunning = Correr
SocUpSimStateLabel = Estado de simulaci\u00f3n:
SocUpSimstateStart = Inicio
SocUpSimstateStop = Pausa
SocUpUnknown = Desconocido
#
# file/ElfHeader.java
#
ElfHeaderEIClassError = No es un archivo de elfos de 32 o 64 bits
ElfHeaderEIDataError = No es un peque\u00f1o o gran archivo codificado endian
ElfHeaderIncorrectEISize = El tama\u00f1o de la secci\u00f3n EI es incorrecto
ElfHeaderIncorrectESize = El tama\u00f1o de la secci\u00f3n E es incorrecto
ElfHeaderIncorrectMagic = El archivo no contiene la magia elfa correcta; probablemente no es un archivo elfa
ElfHeaderNoErrors = La cabecera es correcta
ElfHeaderReadingFileError = Error al leer el archivo
ElfHeaderUnknownArchitecture = Arquitectura desconocida
#
# file/ElfProgramHeader.java
#
ProgHeaderNotFound = No se ha encontrado la cabecera del programa.
ProgHeaderReadError = Error en la lectura de la cabecera del programa.
ProgHeaderSizeError = Desajuste de tama\u00f1o en la cabecera del programa.
ProgHeaderSuccess = \u00c9xito
#
# file/ElfSectionHeader.java
#
ElfSectHeadMultiStringtabError = Encontr\u00e9 m\u00faltiples tablas de cadenas, no soportadas por el momento.
ElfSectHeadMultiSymtabError = Encontr\u00e9 m\u00faltiples tablas de s\u00edmbolos, no soportadas por el momento;
ElfSectHeadNotFound = Cabecera de secci\u00f3n no encontrada.
ElfSectHeadReadError = Cabecera de la secci\u00f3n de lectura de errores.
ElfSectHeadSizeError = Desajuste de tama\u00f1o en el encabezado de la secci\u00f3n.
ElfSectHeadStingIdxError = \u00cdndice de cadenas de error.
ElfSectHeadStingNotFound = Nombre de la secci\u00f3n no encontrado.
ElfSectHeadStingReadError = Error al leer la tabla de cadenas.
ElfSectHeadStingTypeError = Error de tipo de cadena.
ElfSectHeadSuccess = \u00c9xito
ElfSymTableNotFound = No he podido encontrar la tabla de s\u00edmbolos.
ElfSymTableReadError = No se pudo leer la tabla de s\u00edmbolos.
#
# file/ProcessorReadElf.java
#
ProcReadElf64BitNotSupportedYet = Logisim a\u00fan no es compatible con los archivos de elfos de 64 bits.
ProcReadElfArchError = El archivo Elf es para un procesador"%s" mientras que deber\u00eda ser para un procesador"%s".
ProcReadElfEndianMismatch = Desajuste endiano, el archivo elf es"%s" mientras que el procesador pidi\u00f3"%s".
ProcReadElfErrorOpeningFile = Imposible abrir el archivo elf-file
ProcReadElfLoadableSectionNotFound = La secci\u00f3n de carga no se encuentra en el archivo elf.
ProcReadElfLoadableSectionReadError = Error en la lectura de la secci\u00f3n cargable.
ProcReadElfLoadableSectionSizeError = Desajuste de tama\u00f1o en la secci\u00f3n de carga.
ProcReadElfLoadableSectionTooBig = El tama\u00f1o de la secci\u00f3n cargable es mayor que el tama\u00f1o soportado por logisim.
ProcReadElfMemoryError = Se ha producido un error al escribir una secci\u00f3n cargable en la memoria.\nAseg\u00farese de tener un componente de memoria SOC disponible para la zona de memoria:\n%s...%s
ProcReadElfNotExecutable = El archivo elf-file no es un ejecutable
ProcReadElfSuccess = \u00c9xito
#
# gui/AssemblerPanel.java
#
AsmPanAmsFileExtention = Archivos de ensamblaje (.asm,.S)
AsmPanAssemble = Ensamblar el c\u00f3digo (ALT-A)
AsmPanDocumentChangedSave = Hay cambios en su documento, \u00bfguardarlos?
AsmPanErrorCreateFile = No se puede crear el archivo de ensamblaje.
AsmPanErrorReadingFile = No se puede leer el archivo
AsmPanNextError = Saltar al siguiente error (CTRL-N)
AsmPanOpenFile = Leer un fichero (CTRL-L)
AsmPanPreviousError = Saltar al error anterior (CTRL-P)
AsmPanReadAsmFile = Seleccione un archivo para leer
AsmPanRun = Ejecutar el c\u00f3digo (ALT-R)
AsmPanSaveAsmFile = Seleccione un archivo para guardar
AsmPanSaveFile = Guardar archivo (CTRL-S)
AsmPanSaveFileAs = Guardar archivo como
AsmPanSaveFirstBeforeOpen = Hay cambios en su documento\n\u00bfDesea guardarlas antes de abrir un nuevo archivo?
AssemblerAssembleSuccess = \u00c9xito!\nNo se han encontrado errores en su c\u00f3digo.
AssemblerRunSuccess = Ha cargado con \u00e9xito el programa en la memoria.\nPara ejecutar el programa, por favor, aseg\u00farese de ello:\na) usted habilita las garrapatas\nb) usted establece el cpu en modo de ejecuci\u00f3n
AssemblerUnableToDownload = No se puede almacenar el programa en la memoria,\npor favor, aseg\u00farese de tener suficiente memoria disponible\nen las posiciones de memoria correctas.
#
# gui/BreakpointPanel.java
#
RV32imAsmLineIndicator = L\u00ednea %d de %d
RV32imRemoveBreakPoint = Eliminar el punto de ruptura
RV32imSetBreakpoint = A\u00f1adir punto de ruptura
#
# gui/BusTransactionInsertionGui.java
#
SocTransInsAddress = Direcci\u00f3n del autob\u00fas: 0x
SocTransInsAtomicRequest = Transacci\u00f3n at\u00f3mica
SocTransInsByteAccess = Transacci\u00f3n de bytes
SocTransInsHalfWordAccess = Transacci\u00f3n de media palabra (2 bytes)
SocTransInsInputData = Datos para escribir: 0x
SocTransInsInsertTransaction = Insertar la transacci\u00f3n en el autob\u00fas
SocTransInsManual = Manual insertado
SocTransInsReadData = Datos devueltos:
SocTransInsReadRequest = Solicitud de lectura de bus
SocTransInsTransResultTitle = Resultado de la transacci\u00f3n insertada:
SocTransInsWordAccess = Transacci\u00f3n Word (4 bytes)
SocTransInsWriteRequest = Solicitud de escritura de bus
#
# gui/CpuDrawSupport.java
#
Rv32imAsmInstruction = Montaje:
Rv32imBinInstruction = Opcode:
Rv32imEmptyTrace = No hay trazas de ejecuci\u00f3n disponibles
Rv32imExecutionTrace = Traza de ejecuci\u00f3n (\u00faltima ejecuci\u00f3n en la parte superior):
Rv32imProgramCounter = pc:
Rv32imRegisterFile = Archivo de registro:
#
# gui/SocCPUShape.java
#
RV32ShapeSimControl = Control de simulaci\u00f3n
#
# memory/SocMemory.java
#
SocMemBase = Base:
SocMemSizeStr = Tama\u00f1o:
#
# memory/SocMemoryAttributes.java
#
SocMemSize = Ancho de direcci\u00f3n de byte:
SocMemStartAddress = Direcci\u00f3n de inicio:
#
# nios2/Nios2.java
#
Nios2A = A
Nios2B = B
Nios2C = C
Nios2Component = Simulador de Nios2s
Nios2Dataa = Datos A
Nios2Datab = Datos B
Nios2Done = Hecho
Nios2N = N
Nios2ReadRa = Leer Ra
Nios2ReadRb = Leer Rb
Nios2Result = Resultado
Nios2Start = Inicio
Nios2WriteRc = Escribir Rc
#
# nios2/Nios2Attributes.java
#
nios2BreakVector = Vector de ruptura
#
# nios2/Nios2CustomInstructions.java
#
AssemblerExpectedFourArguments = Se esperan cuatro argumentos
Nios2DonePinError = El pin hecho no definido o en estado de error no puede continuar.\n Por favor, compruebe el pin hecho.
#
# nios2/Nios2OtherControlInstructions.java
#
AssemblerExpectedZeroOrOneArgument = No se espera ning\u00fan o ning\u00fan argumento
Nios2AssemblerExpectedBracketedRegister = Se espera un registro entre corchetes, por ejemplo (r1)
Nios2AssemblerExpectedImmediateIndexedRegister = Se espera un registro indexado inmediato, por ejemplo, 5(r1)
Nios2CannotUseControlRegister = No se puede utilizar un registro de control en este contexto.
Nios2CannotUseCustomRegister = No se puede utilizar un registro personalizado en este contexto
Nios2ExpectedControlRegister = Se espera un registro de control (p. ej. ctl4)
#
# nios2/Nios2ProgramControlInstructions.java
#
AssemblerExpextedImmediateOrLabel = Se espera un valor inmediato o una etiqueta
#
# nios2/Nios2State.java
#
Nios2Bstatus = bstatus
Nios2Estatus = estatus
Nios2Status = estado
#
# pio/PioAttributes.java
#
SicPioIrqType = Tipo de Irq:
SocPioAnyEdge = Cualquier borde
SocPioBidir = Puertos bidireccionales (triest\u00e1ticos)
SocPioCaptureEdge = Tipo de captura:
SocPioDirection = Direcci\u00f3n:
SocPioFallingEdge = Borde descendente
SocPioGenIRQ = IRQ habilitado:
SocPioInout = Puertos de entrada y salida
SocPioInputCaptureBit = Captura de borrado de bits:
SocPioInputOnly = S\u00f3lo puertos de entrada
SocPioInputsSyncCapture = Captura sincronizada:
SocPioIrQEdge = Borde
SocPioIrqLevel = Nivel
SocPioOutputIndividualBits = Bit de salida configurado/limpio:
SocPioOutputOnly = S\u00f3lo puertos de salida
SocPioOutputResetValue = Valor de reset de salida:
SocPioRisingEdge = Borde ascendente
#
# pio/PioMenu.java
#
PioMenuBidirFunctionsRemark = /* Con las siguientes funciones se puede ajustar o leer el registro bidireccional\n * a 1 indica que el bit respect es una salida, a 0 indica que es una entrada\n * Nota: s\u00f3lo se utilizan los porcentajes m\u00e1s bajos de bits.\n */
PioMenuCaptureAll = borrar todos los bits del registro de captura independientemente del valor del par\u00e1metro "value".
PioMenuCaptureAny = al menos un cambio de 0 a 1 o de 1 a 0
PioMenuCaptureBit = borrar los bits del registro de captura que son 1 en el par\u00e1metro "valor
PioMenuCaptureFalling = al menos un cambio de 1 a 0
PioMenuCaptureRising = al menos un cambio de 0 a 1
PioMenuEdgeCaptureRemark = /* Con las siguientes funciones se puede borrar o leer el registro de captura de bordes\n * en caso de que el registro de borde se lea en voz alta, un 1 en una posici\u00f3n indica que el\n * la entrada respectiva tiene un %s de sombrero,\n * de lo contrario, la entrada respectiva no ha cambiado.\n *\n * Escribir a este registro ser\u00e1 %s.\n * Nota: s\u00f3lo se utilizan los porcentajes m\u00e1s bajos de bits.\n */
PioMenuInputDataFunctionRemark = /* Con la siguiente funci\u00f3n los valores de entrada del PIO pueden ser\n * Leer en voz alta.\n * Esta funci\u00f3n devuelve el valor respectivo\n * Nota: s\u00f3lo los %s de bits inferiores son v\u00e1lidos.\n */
PioMenuIrqEdge = bit correspondiente en el registro de captura
PioMenuIrqLevel = entrada correspondiente
PioMenuMaskFunctionsRemark = /* Con las siguientes funciones se puede ajustar o leer el registro de la m\u00e1scara de interrupci\u00f3n.\n * Un 1 en una ubicaci\u00f3n espec\u00edfica indica que se generar\u00e1 una interrupci\u00f3n.\n * si el %s es igual a 1.\n * Nota: s\u00f3lo se utilizan los porcentajes m\u00e1s bajos de bits.\n */
PioMenuOutClearRemark = /* Con la siguiente funci\u00f3n los bits que son 1 en el par\u00e1metro "value" forzar\u00e1n a\n * la salida correspondiente a 0\n * Nota: s\u00f3lo se utilizan los porcentajes m\u00e1s bajos de bits.\n */
PioMenuOutputDataFunctionRemark = /* Con la siguiente funci\u00f3n los valores de salida del PIO pueden ser\n *Set*\n * Esta funci\u00f3n toma el nuevo valor de salida como par\u00e1metro "valor".\n * Nota: s\u00f3lo son v\u00e1lidos los bits %s inferiores del par\u00e1metro "value" proporcionado.\n */
PioMenuOutSetRemark = /* Con la siguiente funci\u00f3n los bits que son 1 en el par\u00e1metro "value" forzar\u00e1n a\n * la salida correspondiente a 1\n * Nota: s\u00f3lo se utilizan los porcentajes m\u00e1s bajos de bits.\n */
#
# pio/SocPio.java
#
SocPioBidirPinx = Bidir bit %s
SocPioBidirs = Pines bidireccionales
SocPioComponent = Expansor de entradas/salidas en paralelo
SocPioInputPinx = Bit de entrada %s
SocPioInputs = Pines de entrada
SocPioIrqOutput = Salida de Irq
SocPioOutputPinx = Bit de salida %s
SocPioOutputs = Pines de salida
SocPioResetInput = Entrada de reset
#
# rv32im/RV32im_M_ExtensionInstructions.java
#
AssemblerExpectedRegister = Se espera un registro
AssemblerExpectedThreeArguments = Se esperan tres argumentos
AssemblerUnknownRegister = Registro desconocido
#
# rv32im/Rv32im_riscv.java
#
Rv32imClockInput = Entrada de reloj
Rv32imComponent = Simulador de mensajer\u00eda instant\u00e1nea Risc V
Rv32imIrqInput = Entrada IRQ %s
Rv32imResetInput = Entrada de reset
#
# rv32im/RV32im_state.java
#
RV32imBreakPointReached = La ejecuci\u00f3n se detiene debido a un punto de interrupci\u00f3n establecido en la instrucci\u00f3n actual.
RV32imFetchExecutionError = Error en la ejecuci\u00f3n de una instrucci\u00f3n recuperada
RV32imFetchInvalidInstruction = Instrucci\u00f3n inv\u00e1lida recuperada
RV32imFetchInvInstrAsm = Instrucci\u00f3n no v\u00e1lida!
RV32imFetchTransaction = -> Recuperar error de transacci\u00f3n.
SocHiddenForFasterSimulation = Contenidos ocultos para una simulaci\u00f3n m\u00e1s r\u00e1pida
#
# rv32im/RV32imAttributes.java
#
rv32ExceptionVector = Vector de excepci\u00f3n
rv32imIrqWidth = N\u00famero de l\u00edneas IRQ
rv32ResetVector = Restablecer vector
rv32StateVisable = Estado visible:
#
# rv32im/RV32imControlTransferInstructions.java
#
AssemblerExpectedNoArguments = No se esperan argumentos
AssemblerExpectedOneArgument = Esperaba un argumento
Rv32imAssemblerExpectedOneOrTwoArguments = Se esperan uno o dos argumentos
Rv32imAssemblerExpectedTwoOrThreeArguments = Se esperan dos o tres argumentos
#
# rv32im/RV32imEnvironmentCallAndBreakpoints.java
#
Rv32imECABNotImplmented = Actualmente no se han implementado los llamados y puntos de ruptura ambientales.
#
# rv32im/RV32imIntegerRegisterImmediateInstructions.java
#
RV32imAssemblerBUG = \u00a1BUG!
#
# rv32im/RV32imLoadAndStoreInstructions.java
#
AssemblerExpectedImmediateValue = Se espera un valor inmediato
AssemblerExpectedTwoArguments = Se esperan dos argumentos
AssemblerImmediateOutOfRange = El valor inmediato est\u00e1 fuera de rango
LoadStoreErrorInReadTransaction = Error al realizar una carga desde el sistema de memoria:
LoadStoreErrorInWriteTransaction = Error al realizar un almacenamiento en el sistema de memoria:
RV32imAssemblerExpectedBracketedRegister = Se espera un registro entre corchetes, por ejemplo (x1)
RV32imAssemblerExpectedImmediateIndexedRegister = Se espera un registro indexado inmediato, por ejemplo, 5(x1)
#
# rv32im/Rv32imMemoryOrderingInstructions.java
#
RV32imAssemblerNotSupportedYet = Opcode asm no soportado
Rv32imMOINotImplmented = Actualmente las instrucciones para ordenar la memoria no est\u00e1n implementadas.
#
# Soc.java
#
socLibrary = Componentes de System On Chip
SocMemoryComponent = Simulador de memoria
#
# util/AbstractAssembler.java
#
AssemblerUnknownOpcode = Opcode desconocido
UnknownInstruction = Instrucci\u00f3n desconocida
#
# util/Assembler.java
#
AssemblerAssumingEntryPoint = Asumiendo la direcci\u00f3n m\u00e1s baja con una instrucci\u00f3n como punto de entrada.\nPara asegurarse de que su cpu comienza a ejecutarse en la direcci\u00f3n correcta\npor favor, a\u00f1ada una etiqueta llamada '_start' en la ubicaci\u00f3n\ndonde su cpu deber\u00eda empezar a ejecutar el programa.
AssemblerCannotUseInsideMacro = Esta construcci\u00f3n no se puede utilizar dentro de una definici\u00f3n de macro
AssemblerEndOfMacroNotFound = No se pudo encontrar el final de la definici\u00f3n de macro
AssemblerExpectedMacroName = Se espera un nombre de la macroinstrucci\u00f3n
AssemblerExpectedMacroNrOfParameters = N\u00famero esperado de par\u00e1metros de macro
AssemblerExpectingLabelIdentifier = Esperando una etiqueta
AssemblerMissingLabelBefore = Para este operador debe ser una etiqueta
AssemblerNoExecutableSection = No se han encontrado instrucciones que puedan ejecutarse.
AssemblerReguiresNumberAfterMath = Despu\u00e9s de una operaci\u00f3n matem\u00e1tica debe seguir un n\u00famero
AssemblerUnknowCharacter = Car\u00e1cter desconocido
AssemblerWrongClosingBracket = Este soporte de cierre no est\u00e1 soportado
AssemblerWrongOpeningBracket = Este soporte de apertura no est\u00e1 soportado
#
# util/AssemblerAsmInstruction.java
#
AssemblerCouldNotFindAddressForLabel = No se pudo determinar una direcci\u00f3n para esta etiqueta
AssemblerCouldNotFindValueForDefine = No se pudo encontrar una definici\u00f3n de este par\u00e1metro
AssemblerDivZero = Dividir por cero error
AssemblerExpectedImmediateValueAfterMath = Se espera un valor inmediato despu\u00e9s de una operaci\u00f3n matem\u00e1tica
#
# util/AssemblerInfo.java
#
AssemblerDuplicatedLabelNotSupported = Los nombres de las etiquetas deben ser \u00fanicos, se encuentran m\u00faltiples definiciones de esta etiqueta
AssemblerDuplicatedName = No se puede usar el mismo nombre para un.equ y una etiqueta
AssemblerDuplicatedSectionError = Los nombres de las secciones deben ser \u00fanicos, encontr\u00e1ndose varias secciones con este nombre
AssemblerExpectedLabel = Se espera una etiqueta
AssemblerExpectedLabelAndNumber = Se espera una etiqueta seguida de un valor inmediato
AssemblerExpectedParameter = Se espera un par\u00e1metro en esta posici\u00f3n
AssemblerExpectingNumber = Se espera un n\u00famero
AssemblerExpectingPositiveNumber = Se espera un n\u00famero positivo
AssemblerExpectingSectionName = Esperando un nombre para esta secci\u00f3n
AssemblerExpectingString = Se espera una cadena
AssemblerMacroIncorrectNumberOfParameters = N\u00famero incorrecto de par\u00e1metros de macro especificados
AssemblerOverlappingSections = Esta secci\u00f3n se solapa con otra secci\u00f3n
AssemblerUnknownIdentifier = No conozco este identificador
AssemblerUnsupportedAssemblerInstruction = Esta instrucci\u00f3n de ensamblador no se conoce
AssemblerValueOutOfRange = El valor est\u00e1 fuera de rango
#
# util/AssemblerMacro.java
#
AssemblerMacroCallingEachotherDeadlock = Las macros se llaman entre s\u00ed causando una situaci\u00f3n de bloqueo
AssemblerMacroCannotUseRecurency = Macro se est\u00e1 llamando a s\u00ed misma causando una situaci\u00f3n de bloqueo
AssemblerMacroParameterNotDefined = Este par\u00e1metro de macro no est\u00e1 definido, verifique el n\u00famero de par\u00e1metros en su definici\u00f3n de macro.
AssemblerUnknownLabel = Esta etiqueta no ha sido definida, por lo tanto no puedo usarla.
#
# vga/SocVga.java
#
SocVgaComponent = Pantalla VGA
#
# vga/VgaAttributes.java
#
VgaBufferAddress = Direcci\u00f3n del b\u00fafer de p\u00edxeles:
VgaInitialDisplayMode = Modo inicial:
VgaMode1024x768 = 1024x768
VgaMode160x120 = 160x120
VgaMode320x240 = 320x240
VgaMode640x480 = 640x480
VgaMode800x600 = 800x600
VgaSoft1024x768 = Software 1024x768:
VgaSoft160x120 = Software 160x120:
VgaSoft320x240 = Software 320x240:
VgaSoft640x480 = Software 640x480:
VgaSoft800x600 = Software 800x600:
VgaStartAddress = Direcci\u00f3n de la base:
#
# vga/VgaMenu.java
#
ErrorCreatingHeaderAndOrCFile = No se pudo crear el encabezado y/o el archivo c!
ExportC = Exportaci\u00f3n de plantillas en C
SelectDirectoryToStoreC = Directorio de sets para almacenar las plantillas C
SuccesCreatingHeaderAndCFile = Ha creado con \u00e9xito los archivos:\n%s\ny\n%s
VgaMenuModeSelectFunctions = /* Con las siguientes funciones se puede manipular el modo vga.\n * La lectura del modo vga devuelve los modos soportados (ver arriba define los posibles modos)\n * Escribir un modo compatible cambiar\u00e1 el modo de visualizaci\u00f3n de la pantalla VGA.\n */


