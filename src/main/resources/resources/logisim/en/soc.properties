#
# bus/SocBus.java
#
SocBusComponent = SOC bus simulator
#
# bus/SocBusAttributes.java
#
SocBusTraceSize = Trace size:
SocBusTraceVisable = Traces visible:
#
# bus/SocBusMenu.java
#
insertTrans = Insert a bus transaction
SocBusMemMap = Show memory map
#
# data/SocBusInfo.java
#
SocBusNotConnected = Not connected to a bus
#
# data/SocBusStateInfo.java
#
SocBusNoTrace = No traces present
SocInsertTransWindowTitle = Insert a transaction to bus:
SocMemMapWindowTitle = Memory Map for bus:
SocMemoryMapOk = Close
SocMemoryMapTitle = Memory Map (red indicates overlapping memory regions):
#
# data/SocBusTransaction.java
#
SocBusStateMaster = Initiator:
SocBusStateNoDataMax10chars = no data
SocBusStateSlave = Reponder:
SocBusStateTraceIndex = Transaction nr.:
SocTransactionByteAccesNoSupport = Slave does not support byte accesses.
SocTransactionByteAccesNoSupportShort = No byte access
SocTransactionHalfWordAccesNoSupport = Slave does not support half word accesses.
SocTransactionHalfWordAccesNoSupportShort = No HW access
SocTransactionMisallignedAddress = Slave detected a misalligned address.
SocTransactionMisallignedAddressShort = Misall. Addr.
SocTransactionMultipleSlaveAnswers = Multiple slaves answered to a transaction. Please check the memory map of your slaves.
SocTransactionMultipleSlaveAnswersShort = Multiple slaves
SocTransactionNoBusConnected = The master component is not connected to any Soc Bus. Please connect the master to a bus component.
SocTransactionNoBusConnectedShort = No bus
SocTransactionNoneAtomicRW = A none atomic read/write action is requested. This is not allowed.
SocTransactionNoneAtomicRWShort = None atomic RW
SocTransactionNoRespons = No slave component answered to the request. Please check the memory address of the request and the memory map of your system.
SocTransactionNoResponsShort = No response
SocTransactionNoSlavesAttached = The bus that is connected to the master has no slaves attached. Please attach some slaves to the bus.
SocTransactionNoSlavesAttachedShort = No slaves
SocTransactionReadOnlyAccessError = Slave supports only read accesses on this address
SocTransactionReadOnlyAccessErrorShort = Read only
SocTransactionRegisterDoesNotExist = Slave does not support any access on this address
SocTransactionRegisterDoesNotExistShort = No access
SocTransactionSuccessfull = No error has occured, the transaction is successful.
SocTransactionSuccessfullShort = Success
SocTransactionUnknownError = Bizar, this error message should never occur and represents a bug in logisim.
SocTransactionUnknownErrorShort = BUG!
SocTransactionWordAccesNoSupport = Slave does not support word accesses.
SocTransactionWordAccesNoSupportShort = No word access
SocTransactionWriteOnlyAccessError = Slave does not support a read action on this address.
SocTransactionWriteOnlyAccessErrorShort = Write only
#
# data/SocMemMapModel.java
#
SocMemMapEmpty = Empty (no slaves)
SocMemMapEndAddress = End address:
SocMemMapSlaveName = Name of component:
SocMemMapStartAddress = Start address:
#
# data/SocSimulationManager.java
#
SocBusManagerSelectBus = Please select a bus to connect to
SocBusSelectAttr = Connected bus
SocBusSelectAttrClick = Click to select
SocManagerNoBusses = No busses available, please add a SOC-bus to your schematic
#
# data/SocUpSimulationState.java
#
SocUpSimHalt = Halted
SocUpSimHaltBreak = Breakpoint
SocUpSimHaltError = Error
SocUpSimRunning = Running
SocUpSimStateLabel = Simstate:
SocUpSimstateStart = Start
SocUpSimstateStop = Pause
SocUpUnknown = Unknown
#
# file/ElfHeader.java
#
ElfHeaderEIClassError = Not a 32 or 64 bit elf file
ElfHeaderEIDataError = Not a little or big endian encoded file
ElfHeaderIncorrectEISize = The size for the EI-section is incorrect
ElfHeaderIncorrectESize = The size for the E-section is incorrect
ElfHeaderIncorrectMagic = The file does not contain the correct elf-magic; probably not an elf-file
ElfHeaderNoErrors = Header is correct
ElfHeaderReadingFileError = Error reading the file
ElfHeaderUnknownArchitecture = Unknow architecture
#
# file/ElfProgramHeader.java
#
ProgHeaderNotFound = Program header not found.
ProgHeaderReadError = Error reading program header.
ProgHeaderSizeError = Size mismatch in program header.
ProgHeaderSuccess = Success
#
# file/ElfSectionHeader.java
#
ElfSectHeadNotFound = Section header not found.
ElfSectHeadReadError = Error reading section header.
ElfSectHeadSizeError = Size mismatch in section header.
ElfSectHeadSuccess = Success
#
# file/ProcessorReadElf.java
#
ProcReadElf64BitNotSupportedYet = Logisim does not yet support 64-bit elf files.
ProcReadElfArchError = Elf file is for a \"%s\" processor whilst it should be for a \"%s\" processor.
ProcReadElfEndianMismatch = Endian mismatch, elf file is \"%s\" whilst the processor requested \"%s\".
ProcReadElfErrorOpeningFile = Impossible to open elf-file
ProcReadElfLoadableSectionNotFound = Loadable section not found in elf file.
ProcReadElfLoadableSectionReadError = Error reading loadable section.
ProcReadElfLoadableSectionSizeError = Size mismatch in loadable section.
ProcReadElfLoadableSectionTooBig = The size of the loadable section is bigger as the size supported by logisim.
ProcReadElfMemoryError = An error occured writing a loadable section to memory.\nMake sure you have a SOC memory component available for the memory region:\n%s...%s
ProcReadElfNotExecutable = The elf-file is not an executable
ProcReadElfSuccess = Success
#
# gui/BusTransactionInsertionGui.java
#
SocTransInsAddress = Bus address: 0x
SocTransInsAtomicRequest = Atomic transaction
SocTransInsByteAccess = Byte transaction
SocTransInsHalfWordAccess = Half word transaction (2 bytes)
SocTransInsInputData = Data to write: 0x
SocTransInsInsertTransaction = Insert the transaction into the bus
SocTransInsManual = Manual inserted
SocTransInsReadData = Data returned:
SocTransInsReadRequest = Bus read request
SocTransInsTransResultTitle = Result of the inserted transaction:
SocTransInsWordAccess = Word transaction (4 bytes)
SocTransInsWriteRequest = Bus write request
#
# memory/SocMemory.java
#
SocMemBase = Base:
SocMemSizeStr = Size:
#
# memory/SocMemoryAttributes.java
#
SocMemSize = Byte address width:
SocMemStartAddress = Start address:
#
# pio/PioAttributes.java
#
SicPioIrqType = Irq type:
SocPioAnyEdge = Any edge
SocPioBidir = Bidirectional (tristate) ports
SocPioCaptureEdge = Capture type:
SocPioDirection = Direction:
SocPioFallingEdge = Falling edge
SocPioGenIRQ = IRQ enabled:
SocPioInout = Both input and output ports
SocPioInputCaptureBit = Capture bit-clearing:
SocPioInputOnly = Input ports only
SocPioInputsSyncCapture = Sync. capture:
SocPioIrQEdge = Edge
SocPioIrqLevel = Level
SocPioOutputIndividualBits = Output bit set/clear:
SocPioOutputOnly = Output ports only
SocPioOutputResetValue = Output reset value:
SocPioRisingEdge = Rising edge
#
# pio/PioMenu.java
#
PioMenuBidirFunctionsRemark = /* With the following functions the bi-directional register can be set or read out\n * a 1 indicates that the respect. bit is an output, a 0 indicates it is an input\n * Note: only the lower %s bits are used.\n */
PioMenuCaptureAll = clear all bits in the capture register independently of the value of the parameter "value"
PioMenuCaptureAny = at least one change from 0 to 1 or from 1 to 0
PioMenuCaptureBit = clear the bits in the capture register that are 1 in the parameter "value"
PioMenuCaptureFalling = at least one change from 1 to 0
PioMenuCaptureRising = at least one change from 0 to 1
PioMenuEdgeCaptureRemark = /* With the following functions the edge capture register can be cleared or read out\n * in case the edge register is read out a 1 on a position indicates that the\n * respective input has hat %s,\n * otherwise the respective input has not changed.\n * \n * Writing to this register will %s.\n * Note: only the lower %s bits are used.\n */
PioMenuInputDataFunctionRemark = /* With the following function the input values of the PIO can be\n * read out.\n * This function returns the respective value\n * Note: only the lower %s bits are valid\n */
PioMenuIrqEdge = corresponding bit in the capture register
PioMenuIrqLevel = corresponding input
PioMenuMaskFunctionsRemark = /* With the following functions the Interrupt mask register can be set or read out.\n * A 1 on a specific location indicates that an interrupt will be generated\n * if the %s is equal to 1.\n * Note: only the lower %s bits are used.\n */
PioMenuOutClearRemark = /* With the following function the bits that are 1 in the parameter "value" will force\n * the corresponding output to 0\n * Note: only the lower %s bits are used.\n */
PioMenuOutputDataFunctionRemark = /* With the following function the output values of the PIO can be\n * set.\n * This function takes the new output value as parameter "value"\n * Note: only the lower %s bits of the provided parameter "value" are valid\n */
PioMenuOutSetRemark = /* With the following function the bits that are 1 in the parameter "value" will force\n * the corresponding output to 1\n * Note: only the lower %s bits are used.\n */
#
# pio/SocPio.java
#
SocPioBidirPinx = Bidir bit %s
SocPioBidirs = Bi-directional pins
SocPioComponent = Parallel input/output expander
SocPioInputPinx = Input bit %s
SocPioInputs = Input pins
SocPioIrqOutput = Irq output
SocPioOutputPinx = Output bit %s
SocPioOutputs = Output pins
SocPioResetInput = Reset input
#
# rv32im/Rv32im_riscv.java
#
Rv32imClockInput = Clock input
Rv32imComponent = Risc V IM simulator
Rv32imIrqInput = IRQ input %s
Rv32imResetInput = Reset input
#
# rv32im/RV32im_state.java
#
Rv32imAsmInstruction = Assembly:
Rv32imBinInstruction = Opcode:
Rv32imEmptyTrace = No execution traces available
Rv32imExecutionTrace = Execution trace (last executed on top):
RV32imFetchExecutionError = Error in executing fetched instruction
RV32imFetchInvalidInstruction = Invalid instruction fetched
RV32imFetchInvInstrAsm = Invalid instruction!
RV32imFetchTransaction = -> Fetch transaction error.
Rv32imProgramCounter = pc:
Rv32imRegisterFile = Register file:
SocHiddenForFasterSimulation = Contents hidden for faster simulation
#
# rv32im/RV32imAttributes.java
#
rv32ExceptionVector = Exception vector
rv32imIrqWidth = Number of IRQ lines
rv32ResetVector = Reset vector
rv32StateVisable = State visible:
#
# rv32im/RV32imEnvironmentCallAndBreakpoints.java
#
Rv32imECABNotImplmented = Currently the environmental call and breakpoints are not implemented
#
# rv32im/RV32imLoadAndStoreInstructions.java
#
RV32imLoadStoreErrorInReadTransaction = Error performing a load from memory system:
RV32imLoadStoreErrorInWriteTransaction = Error performing a store to the memory system:
#
# rv32im/Rv32imMemoryOrderingInstructions.java
#
Rv32imMOINotImplmented = Currently the memory ordering instructions are not implemented
#
# rv32im/RV32imMenu.java
#
ProcReadElfLoadedAndEntrySet = Successfully loaded the elf file into memory.\nThe entry point of the executable has been set to the processor.\n\nImportant:\n   As the elf file has no information on the exception vectors\n   you have to control them yourself!
RV32imCpuStateWindow = Risc V processor state
Rv32imErrorReadingElfTitle = Error in reading elf file
Rv32imReadElf = Read elf file
Rv32imSelectElfFile = Select elf file to import
Rv32imShowState = Show CPU state
#
# rv32im/RV32imShape.java
#
# ==> RV32ShapeSimControl = 
#
# Soc.java
#
socLibrary = System On Chip components
SocMemoryComponent = Memory simulator
#
# vga/SocVga.java
#
SocVgaComponent = VGA screen
#
# vga/VgaAttributes.java
#
VgaBufferAddress = Pixel buffer Address:
VgaInitialDisplayMode = Initial mode:
VgaMode1024x768 = 1024x768
VgaMode160x120 = 160x120
VgaMode320x240 = 320x240
VgaMode640x480 = 640x480
VgaMode800x600 = 800x600
VgaSoft1024x768 = Software 1024x768:
VgaSoft160x120 = Software 160x120:
VgaSoft320x240 = Software 320x240:
VgaSoft640x480 = Software 640x480:
VgaSoft800x600 = Software 800x600:
VgaStartAddress = Base address:
#
# vga/VgaMenu.java
#
ErrorCreatingHeaderAndOrCFile = Could not create header and/or c file!
ExportC = Export C-templates
SelectDirectoryToStoreC = Set directory to store the C-templates
SuccesCreatingHeaderAndCFile = Sucessfully created the files:\n%s\nand\n%s
VgaMenuModeSelectFunctions = /* With the following functions the vga mode can be manipulated.\n * Reading the vga mode returns the supported modes (see above defines of possible modes)\n * Writing a supported mode will change the display mode of the VGA display\n */


